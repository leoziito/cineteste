<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CINERAVE - App Todo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap');
        body { font-family: 'Inter', sans-serif; }
        
        /* Adiciona uma transição suave para as cores ao trocar de tema */
        body, .bg-app, .text-app, .bg-secondary, .bg-accent { transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; }

        /* Variáveis de Tema: Modo Claro (Padrão: Fundo Branco, Texto Preto) */
        :root {
            --bg-primary: #ffffff; /* Fundo Branco */
            --text-primary: #000000; /* Texto Preto */
            --bg-secondary: #f3f4f6; /* Componentes/Fundo secundário (cinza claro) */
            --bg-accent: #1f2937; /* Cor de Destaque/Botões (cinza escuro) */
            --bg-accent-lighter: #4b5563; /* Cor de Destaque/Botões (cinza médio) */
        }
        
        /* Variáveis de Tema: Modo Escuro */
        .dark {
            --bg-primary: #111827; /* Fundo Escuro (Quase Preto) */
            --text-primary: #ffffff; /* Texto Branco */
            --bg-secondary: #1f2937; /* Componentes/Fundo secundário (cinza escuro) */
            --bg-accent: #4b5563; /* Cor de Destaque/Botões (cinza médio) */
            --bg-accent-lighter: #6b7280;
        }

        /* Classes CSS para usar as variáveis do tema */
        .bg-app { background-color: var(--bg-primary); }
        .text-app { color: var(--text-primary); }
        .bg-secondary-theme { background-color: var(--bg-secondary); }
        .bg-accent-theme { background-color: var(--bg-accent); }
        .input-style {
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db; /* gray-300 */
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            width: 100%;
            transition: border-color 0.2s;
        }
        .dark .input-style { border-color: #374151; /* gray-700 */ }
        .input-style:focus {
            border-color: var(--bg-accent);
            outline: none;
            box-shadow: 0 0 0 1px var(--bg-accent);
        }

        /* Estilo para garantir a área do feed vazia */
        .empty-feed {
            min-height: 50vh;
        }

        /* Classe para o Modal */
        .modal {
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        
        /* Estilo para as caixas de seleção personalizadas na aba Explorar */
        .select-style {
            appearance: none; /* Remove a aparência nativa */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%234B5563' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5em;
            padding-right: 2.5rem; /* Espaço para o ícone */
            cursor: pointer;
        }
        .dark .select-style {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m6 9 6 6 6-6'/%3E%3C/svg%3E");
        }

        /* Centraliza o texto do rodapé e define o tamanho */
        .footer-text {
            text-align: center;
            font-size: 0.65rem; /* Menor que text-xs (0.75rem) */
            line-height: 1.2;
            opacity: 0.7;
        }
        
        /* Estilo para posters no feed */
        .poster-card {
            background-color: var(--bg-secondary);
            aspect-ratio: 2 / 3; /* Proporção de poster */
            background-size: cover;
            background-position: center;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            min-width: 120px;
        }

        .dark .poster-card {
            box-shadow: 0 4px 6px -1px rgba(255, 255, 255, 0.05), 0 2px 4px -2px rgba(255, 255, 255, 0.05);
        }

        .poster-card:hover {
            transform: scale(1.03);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -4px rgba(0, 0, 0, 0.3);
        }

        /* A classe poster-info será mantida, mas estará vazia no HTML gerado */
        .poster-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 0.5rem;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.2));
            color: white;
            opacity: 0; /* Torna invisível, mas o elemento existe */
            transition: opacity 0.2s;
        }
        /* Efeito de hover opcional, mantido para indicar interatividade se o usuário clicar */
        .poster-card:hover .poster-info {
             opacity: 1; 
        }
        
        /* Estilo para o Modal de Notificação Pop-up */
        #notification-modal {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 50;
            max-width: 350px;
            background-color: #1f2937; /* Fundo Escuro para destaque */
            color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -4px rgba(0, 0, 0, 0.3);
            transform: translateX(120%);
            transition: transform 0.4s ease-out;
        }

        #notification-modal.show {
            transform: translateX(0);
        }
        
        /* Spinner de Loading */
        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            width: 1em;
            height: 1em;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Estilo do Modal de Notificações Globais */
        #global-notifications-modal {
            position: fixed;
            top: 64px; /* Abaixo do header */
            right: 0;
            width: 100%;
            max-width: 400px;
            height: calc(100vh - 64px); /* Altura restante */
            z-index: 50;
            background-color: var(--bg-primary);
            box-shadow: -4px 0 10px rgba(0, 0, 0, 0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            overflow-y: auto;
        }
        #global-notifications-modal.active {
            transform: translateX(0);
        }
        .dark #global-notifications-modal {
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Estilo do Modal de Confirmação e Detalhes (Fundo Escuro) */
        .confirmation-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s;
            padding: 0; /* Remove padding padrão para melhor UX mobile */
        }
        .confirmation-modal.active {
            opacity: 1;
            visibility: visible;
        }

        /* Ajuste do modal de detalhes para tela cheia em mobile */
        #content-detail-modal.confirmation-modal.active > div {
            transform: scale(1) translate(0, 0);
            opacity: 1;
        }
        
        /* CORREÇÃO CRÍTICA: Força o modal a ocupar a tela inteira em mobile/pequenas telas */
        #detail-modal-content {
             margin-top: 0 !important;
             height: 100vh !important;
             max-width: 100% !important;
             border-radius: 0 !important;
        }
        /* Fixa o header do detalhe e permite a rolagem apenas no conteúdo abaixo */
        #detail-modal-content > div:nth-child(2) {
             /* O segundo div é o flex-1 overflow-y-auto p-6 space-y-6 */
             height: auto;
             max-height: calc(100% - 64px); /* Ajuste se necessário para telas menores */
             overflow-y: auto;
        }

        @media (min-width: 640px) {
             #detail-modal-content {
                 height: 90vh !important;
                 max-width: 64rem !important; /* max-w-6xl */
                 border-radius: 0.75rem !important;
                 margin-top: 2rem !important;
             }
        }
        
        /* Estilo para a seta de expansão/colapso */
        .season-toggle-btn[aria-expanded="true"] .arrow-icon {
            transform: rotate(180deg);
        }

        /* Estilo para o clique na Notificação (para que pareça clicável) */
        .notification-item-clickable {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .notification-item-clickable:hover {
            background-color: var(--bg-secondary);
        }
        .dark .notification-item-clickable:hover {
             background-color: var(--bg-secondary);
        }
        
        /* Estilo para o Banner Rotativo */
        #current-hero-banner {
            background-size: cover;
            background-position: center;
            position: relative;
            height: 250px; /* Altura padrão para mobile/desktop */
            transition: transform 0.5s, opacity 0.5s;
        }
        @media (min-width: 640px) {
            #current-hero-banner {
                height: 350px;
            }
        }

        /* Estilo para a barra de rolagem horizontal dos carrosséis */
        .horizontal-scroll-container {
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 1rem; /* Espaço para sombra da barra */
            /* Esconde a barra de rolagem para navegadores modernos */
            scrollbar-width: none; /* Firefox */
        }
        .horizontal-scroll-container::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        /* Estilo para os posters dentro do carrossel */
        .carousel-item {
            display: inline-block;
            margin-right: 1rem;
            width: 140px; /* Largura padrão para o poster no carrossel */
            flex-shrink: 0;
        }
        @media (min-width: 640px) {
             .carousel-item {
                 width: 180px;
             }
        }
        
        /* Estilo para rolagem da Sidebar (CORREÇÃO) */
        #sidebar {
            overflow-y: auto;
            scrollbar-width: thin; /* Firefox */
        }
        #sidebar::-webkit-scrollbar {
            width: 6px;
        }
        #sidebar::-webkit-scrollbar-thumb {
            background-color: var(--bg-accent);
            border-radius: 3px;
        }

        /* Ajuste do grid do Explore para 4 colunas em telas maiores (MUITO IMPORTANTE) */
        @media (min-width: 640px) {
             /* SM */
             #explore-results {
                 grid-template-columns: repeat(3, minmax(0, 1fr));
             }
        }
        @media (min-width: 1024px) {
            /* LG (Desktop) */
             #explore-results {
                 grid-template-columns: repeat(4, minmax(0, 1fr));
             }
        }
        /* Garante que o input de filtro seja menor */
        #explore-panel .input-style {
            padding: 0.5rem;
            font-size: 0.875rem; /* text-sm */
        }
        #explore-panel .select-style {
            padding-right: 2rem;
        }
        
        /* NOVO: Estilo para selo de Lançamento */
        .release-badge {
             position: absolute;
             top: 0.5rem;
             right: 0.5rem;
             padding: 0.25rem 0.5rem;
             background-color: #ef4444; /* red-500 */
             color: white;
             font-weight: bold;
             font-size: 0.75rem;
             border-radius: 0.375rem;
             z-index: 10;
        }

    </style>
</head>
<body class="bg-app text-app min-h-screen flex flex-col">

    <div id="admin-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="modal p-6 rounded-xl shadow-2xl w-full max-w-sm mx-4 transition-all duration-300 transform scale-95 opacity-0" id="modal-content">
            <h3 class="text-xl font-bold mb-4">Acesso Administrativo</h3>
            <p class="mb-4 text-sm opacity-80">Por favor, insira a senha para acessar as ferramentas de administração.</p>
            <input type="password" id="admin-password" class="input-style" placeholder="Senha">
            <p id="password-error" class="text-red-500 text-sm mt-2 hidden">Senha incorreta. Tente novamente.</p>
            <div class="flex justify-end space-x-3 mt-6">
                <button id="modal-cancel" class="py-2 px-4 rounded-lg bg-secondary-theme/50 hover:bg-secondary-theme">
                    Cancelar
                </button>
                <button id="modal-confirm" class="py-2 px-4 rounded-lg bg-accent-theme text-white hover:opacity-90">
                    Confirmar
                </button>
            </div>
        </div>
    </div>

    <div id="delete-confirmation-modal" class="confirmation-modal">
        <div class="modal p-6 rounded-xl shadow-2xl w-full max-w-sm mx-4">
            <h3 class="text-xl font-bold mb-4 text-red-600">Confirmação de Exclusão</h3>
            <p class="mb-6">Tem certeza que deseja <span class="font-bold">excluir permanentemente</span> <span id="delete-item-title" class="font-semibold">o conteúdo</span>?</p>
            <div class="flex justify-end space-x-3">
                <button id="delete-cancel-btn" class="py-2 px-4 rounded-lg bg-secondary-theme/50 hover:bg-secondary-theme">
                    Cancelar
                </button>
                <button id="delete-confirm-btn" class="py-2 px-4 rounded-lg bg-red-600 text-white hover:bg-red-700">
                    Excluir
                </button>
            </div>
        </div>
    </div>
    
    <div id="content-detail-modal" class="confirmation-modal">
        <div id="detail-modal-content" class="modal w-full h-full max-w-6xl mx-auto rounded-none sm:rounded-xl shadow-2xl overflow-hidden flex flex-col transition-all duration-300 transform sm:h-[90vh] sm:mt-8">
            <div id="detail-header" class="relative h-64 sm:h-80 bg-cover bg-center flex-shrink-0" style="background-image: url('https://placehold.co/1920x400/1f2937/ffffff?text=Capa+do+Conteúdo');">
                <div class="absolute inset-0 bg-gradient-to-t from-app to-transparent"></div>
                <div class="absolute inset-x-0 top-4 sm:top-8 flex justify-center items-start px-4">
                    <h2 id="detail-title-header" class="text-2xl sm:text-3xl font-extrabold text-white text-center drop-shadow-lg max-w-xs sm:max-w-xl truncate">
                        </h2>
                    <button id="close-detail-modal-btn" class="absolute top-0 right-4 p-2 rounded-full bg-black/50 text-white hover:bg-black/70 z-10">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                    </button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <h2 id="detail-title" class="text-3xl sm:text-4xl font-extrabold flex items-center space-x-3">
                    <span>Título do Conteúdo</span>
                    <span id="series-seasons-badge" class="text-xs font-semibold uppercase bg-blue-500 text-white px-2 py-1 rounded-full hidden"></span>
                    <span id="upcoming-badge" class="text-xs font-semibold uppercase bg-yellow-500 text-black px-2 py-1 rounded-full hidden">Em Breve</span>
                </h2>
                <div class="flex flex-wrap items-center space-x-4 text-sm opacity-70 mb-4">
                    <span id="detail-type-year" class="font-semibold">Tipo | Ano</span>
                    <span id="detail-genres">Gêneros</span>
                </div>

                <button id="main-watch-btn" class="w-full py-3 bg-red-600 text-white font-bold rounded-lg shadow-xl hover:bg-red-700 transition duration-300 flex items-center justify-center space-x-2">
                    <svg id="watch-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    <span id="watch-btn-text">Assistir Agora</span>
                </button>

                <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                    <button id="copy-link-btn" class="flex-1 py-2 px-4 rounded-lg bg-gray-500 text-white hover:bg-gray-600 transition duration-200 flex items-center justify-center space-x-2 text-sm">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07L13 7"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07L11 17"/></svg>
                        <span id="link-text" class="truncate w-full text-center">Copiar Link</span>
                    </button>
                </div>
                
                <div class="border-t pt-4">
                    <h3 class="text-xl font-bold mb-2">Sinopse</h3>
                    <p id="detail-synopsis" class="text-base opacity-90"></p>
                </div>

                <div>
                    <h3 class="text-xl font-bold mb-2">Elenco Principal</h3>
                    <p id="detail-actors" class="text-sm opacity-80"></p>
                </div>

                <div id="series-links-panel" class="hidden border-t pt-4">
                    <h3 class="text-xl font-bold mb-4">Temporadas e Episódios</h3>
                    <div id="seasons-links-container" class="space-y-6">
                        </div>
                </div>
                
                <div id="similar-content-panel" class="border-t pt-6 hidden">
                    <h3 class="text-xl font-bold mb-4">Conteúdo Similar (Recomendados)</h3>
                    <div id="similar-content-container" class="horizontal-scroll-container flex space-x-4">
                         </div>
                    <p id="no-similar-content" class="text-sm opacity-70 hidden mt-4">Nenhum conteúdo similar encontrado.</p>
                </div>


            </div>
        </div>
    </div>
    
    <div id="feedback-modal" class="confirmation-modal">
        <div class="modal p-6 rounded-xl shadow-2xl w-full max-w-lg mx-4">
            <h3 class="text-xl font-bold mb-4">Reportar Erro ou Sugestão</h3>
            <p class="mb-4 text-sm opacity-80">Nos ajude a melhorar! Descreva o problema ou envie sua sugestão.</p>
            <form id="feedback-form" class="space-y-4">
                <div>
                    <label for="feedback-type" class="block text-sm font-medium mb-1">Tipo de Feedback</label>
                    <select id="feedback-type" class="input-style" required>
                        <option value="Link Quebrado">Link Quebrado</option>
                        <option value="Filme Errado">Filme/Série Errado</option>
                        <option value="Sugestão de Conteúdo">Sugestão de Conteúdo</option>
                        <option value="Outro">Outro (Geral)</option>
                    </select>
                </div>
                <div>
                    <label for="feedback-message" class="block text-sm font-medium mb-1">Mensagem</label>
                    <textarea id="feedback-message" rows="4" class="input-style" placeholder="Descreva o problema ou sua sugestão..." required></textarea>
                </div>
                <div class="flex justify-end space-x-3 pt-2">
                    <button type="button" id="feedback-cancel-btn" class="py-2 px-4 rounded-lg bg-secondary-theme/50 hover:bg-secondary-theme">
                        Cancelar
                    </button>
                    <button type="submit" id="feedback-submit-btn" class="py-2 px-4 rounded-lg bg-green-600 text-white hover:bg-green-700 flex items-center justify-center space-x-2">
                        <span id="feedback-submit-text">Enviar Feedback</span>
                        <span id="feedback-loading-spinner" class="hidden spinner"></span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <div id="legal-notice-modal" class="confirmation-modal">
        <div class="modal p-6 rounded-xl shadow-2xl w-full max-w-xl mx-4 relative">
            <h3 class="text-2xl font-bold mb-4 border-b pb-2">Aviso Legal</h3>
            <button id="close-legal-notice-btn" class="absolute top-4 right-4 p-2 rounded-full bg-secondary-theme/70 hover:bg-secondary-theme">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
            </button>
            <div class="space-y-4 pt-2">
                <p class="text-lg font-semibold text-red-500">IMPORTANTE:</p>
                <p class="text-base">
                    Este site <strong>não hospeda</strong> nenhum arquivo de mídia em seus próprios servidores. 
                    Todo o conteúdo disponível é fornecido por terceiros ou incorporado de <strong>fontes públicas disponíveis na internet</strong>.
                </p>
                <p class="text-sm opacity-70">
                    Ao utilizar este serviço, você reconhece e concorda que a responsabilidade pelo conteúdo e pelos links fornecidos é exclusiva de terceiros e das fontes originais.
                </p>
            </div>
        </div>
    </div>


    <div id="notification-modal" class="p-4 hidden" onclick="handleNotifClick(event)">
        <div class="flex space-x-3 items-start">
            <img id="notif-poster" class="w-10 h-15 rounded object-cover flex-shrink-0" src="https://placehold.co/40x60/4b5563/ffffff?text=N" alt="Poster de Notificação">
            <div class="flex-1">
                <p id="notif-title" class="font-bold text-sm truncate">Título da Notificação</p>
                <p id="notif-message" class="text-xs mt-1">Mensagem de alteração.</p>
                <p id="notif-time" class="text-xs opacity-60 mt-1"></p>
            </div>
            <button onclick="hideNotification()" class="text-white opacity-70 hover:opacity-100 p-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
            </button>
        </div>
    </div>

    <div id="global-notifications-modal" class="p-4 overflow-y-auto">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h3 class="text-xl font-bold">Notificações</h3>
            <div class="flex space-x-2">
                <button id="toggle-notif-history" class="text-sm py-1 px-3 rounded-lg bg-gray-500 text-white hover:bg-gray-600">
                    Histórico
                </button>
                <button id="clear-all-notifs-btn" class="text-sm py-1 px-3 rounded-lg bg-red-500 text-white hover:bg-red-600">Limpar Todas</button>
                <button id="close-global-notifs-btn" class="p-1 rounded-lg hover:bg-secondary-theme/80">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                </button>
            </div>
        </div>
        <div id="notifications-list" class="space-y-4">
            <p class="text-center opacity-70">Carregando notificações...</p>
        </div>
    </div>

    <aside id="sidebar" class="fixed top-0 left-0 z-40 w-64 h-full bg-secondary-theme text-app transform -translate-x-full transition-transform duration-300 ease-in-out lg:translate-x-0">
        <div class="p-6 flex flex-col h-full border-r border-gray-700/10 dark:border-white/10">
            
            <button id="admin-button" class="bg-accent-theme hover:opacity-90 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 mb-4">
                Admin
            </button>

            <button id="toggle-continue-watching" class="w-full text-center bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 mb-4 flex items-center justify-center space-x-1 text-sm">
                <span id="continue-watching-text"></span>
            </button>

            <button id="report-error-btn" class="w-full text-center bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 mb-8 text-sm">
                Reportar Erro/Sugestão
            </button>

            <a href="https://livepix.gg/cinerave" target="_blank" class="w-full text-center bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 mb-4 text-sm">
                Doação
            </a>

            <a href="https://chat.whatsapp.com/Lidb3f8U9SsDe10kiLVICR" target="_blank" class="w-full text-center bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 mb-4 text-sm">
                Pedidos (WhatsApp)
            </a>

            <button id="legal-notice-btn" class="w-full text-center bg-gray-700 hover:bg-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200 mb-8 text-sm">
                Aviso Legal
            </button>


            <div class="mt-auto pt-4 border-t border-gray-700/10 dark:border-white/10 space-y-1">
                <p class="footer-text" id="app-version-display">Versão 2.3.9</p>
                <div class="break-words text-center pt-1">
                    <p class="footer-text !text-[0.6rem] !opacity-60">UID:</p>
                    <p class="footer-text !text-[0.55rem] font-mono !opacity-80" id="user-uid-display">Carregando...</p>
                </div>
                <p class="footer-text">Desenvolvido por Leonardo</p>
            </div>
        </div>
    </aside>

    <div id="sidebar-overlay" class="fixed inset-0 bg-black opacity-0 z-30 transition-opacity duration-300 pointer-events-none lg:hidden"></div>

    <div class="flex flex-col flex-1 lg:ml-64">

        <header class="bg-app shadow-xl p-4 sticky top-0 z-20 border-b border-gray-700/10 dark:border-white/10">
            <div class="flex items-center justify-between">
                <button id="menu-toggle" class="lg:hidden p-2 rounded-lg bg-secondary-theme/50 text-app hover:bg-secondary-theme">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg>
                </button>

                <h1 id="app-name" class="text-3xl font-extrabold tracking-tight absolute left-1/2 transform -translate-x-1/2">
                    CINERAVE
                </h1>
                
                <div class="flex items-center space-x-4 ml-auto">
                    <button id="toggle-global-notifs" class="p-2 rounded-lg bg-secondary-theme/50 text-app hover:bg-secondary-theme relative">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"/><path d="M10.375 22a2 6 0 0 1 3.25 0"/></svg>
                        <span id="unread-notifs-count" class="absolute top-1 right-1 h-2 w-2 rounded-full bg-red-500 hidden"></span>
                    </button>

                    <button id="theme-toggle" class="p-2 rounded-lg bg-secondary-theme/50 text-app hover:bg-secondary-theme">
                        <svg id="sun-icon" class="h-5 w-5 hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
                        <svg id="moon-icon" class="h-5 w-5 hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                    </button>
                </div>
            </div>
        </header>

        <nav id="nav-tabs" class="bg-secondary-theme p-3 shadow-inner sticky top-[64px] z-10 border-b border-gray-700/10 dark:border-white/10">
            <div class="flex justify-center space-x-4 sm:space-x-6 max-w-6xl mx-auto">
                <button data-page="inicio" class="nav-tab text-sm sm:text-base font-medium py-1 px-3 rounded-full hover:bg-accent-theme hover:text-white transition duration-200">
                    Início
                </button>
                <button data-page="series" class="nav-tab text-sm sm:text-base font-medium py-1 px-3 rounded-full hover:bg-accent-theme hover:text-white transition duration-200">
                    Séries
                </button>
                 <button data-page="upcoming" class="nav-tab text-sm sm:text-base font-medium py-1 px-3 rounded-full hover:bg-accent-theme hover:text-white transition duration-200">
                    Em Breve
                </button>
                <button data-page="explorar" class="nav-tab text-sm sm:text-base font-medium py-1 px-3 rounded-full hover:bg-accent-theme hover:text-white transition duration-200">
                    Explorar
                </button>
            </div>
        </nav>

        <main id="main-content" class="flex-1 overflow-y-auto bg-app">
            <div id="page-content" class="max-w-6xl mx-auto py-8 px-4 empty-feed">
                
                <div id="default-feed">
                    
                    <div id="hero-banner-container" class="mb-8">
                        </div>
                    
                    <div class="text-center pt-24 pb-8" id="empty-message" style="display: none;">
                        <p class="text-xl opacity-80">Nenhum conteúdo publicado ainda nesta categoria.</p>
                    </div>
                    
                    <div id="carousel-feed-container" class="space-y-12">
                        </div>

                </div>

                <div id="admin-panel" class="hidden h-full flex flex-col items-center py-24 relative">
                    
                    <button id="exit-admin-btn" class="absolute top-4 left-4 p-2 rounded-lg bg-accent-theme text-white hover:opacity-90 transition duration-200 flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                        <span class="hidden sm:inline">Sair do Admin</span>
                    </button>

                    <h2 class="text-4xl font-extrabold mb-10">Painel de Administração</h2>
                    
                    <div class="grid grid-cols-1 sm:grid-cols-4 gap-4 mb-12 w-full max-w-3xl">
                        <button id="nav-publicar-rapida" class="admin-nav-btn flex flex-col items-center justify-center p-4 bg-purple-600 text-white font-bold rounded-xl shadow-xl hover:bg-purple-700 transition duration-300 transform hover:scale-[1.03] opacity-70 min-h-[100px] space-y-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/><path d="M10 9l-3 3 3 3"/></svg>
                            <span class="text-sm">Publicação Rápida</span>
                        </button>
                        <button id="nav-publicar" class="admin-nav-btn flex flex-col items-center justify-center p-4 bg-green-600 text-white font-bold rounded-xl shadow-xl hover:bg-green-700 transition duration-300 transform hover:scale-[1.03] opacity-70 min-h-[100px] space-y-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"/><path d="M5 12h14"/></svg>
                            <span class="text-sm">Publicar Novo</span>
                        </button>
                        <button id="nav-editar" class="admin-nav-btn flex flex-col items-center justify-center p-4 bg-blue-600 text-white font-bold rounded-xl shadow-xl hover:bg-blue-700 transition duration-300 transform hover:scale-[1.03] opacity-70 min-h-[100px] space-y-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.85 0 0 1 4 4L14 17 2 22l5-12z"/></svg>
                            <span class="text-sm">Gerenciar Conteúdo</span>
                        </button>
                        <button id="nav-feedbacks" class="admin-nav-btn flex flex-col items-center justify-center p-4 bg-red-600 text-white font-bold rounded-xl shadow-xl hover:bg-red-700 transition duration-300 transform hover:scale-[1.03] opacity-70 min-h-[100px] space-y-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                            <span class="text-sm">Ver Feedbacks</span>
                        </button>
                    </div>

                    <div id="publish-area" class="w-full max-w-4xl p-6 bg-secondary-theme/50 rounded-xl shadow-lg hidden">
                        
                        <div class="flex mb-8 justify-center space-x-4">
                            <button data-type="movie" class="content-type-btn py-2 px-4 rounded-full font-semibold bg-accent-theme text-white hover:opacity-90 transition duration-200">Filme</button>
                            <button data-type="series" class="content-type-btn py-2 px-4 rounded-full font-semibold hover:bg-accent-theme hover:text-white transition duration-200">Série</button>
                        </div>

                        <form id="content-form" class="space-y-6">
                            <h3 id="form-title" class="text-2xl font-bold border-b pb-3 mb-6">Adicionar Novo Filme</h3>

                            <input type="hidden" id="content-doc-id" value=""> 

                            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 mb-8">
                                <div class="relative w-full">
                                    <input type="text" id="tmdb-search-input" class="input-style pr-10" placeholder="🔍 Buscar filme/série/coleção no TMDB">
                                    <div id="tmdb-results" class="absolute z-10 w-full mt-1 rounded-lg shadow-lg bg-secondary-theme border border-gray-300 dark:border-gray-700 max-h-60 overflow-y-auto hidden">
                                        </div>
                                </div>
                                <div id="poster-preview" class="w-24 h-36 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center text-xs text-gray-500 flex-shrink-0">
                                    Poster
                                </div>
                            </div>

                            <div id="schedule-fields" class="p-4 bg-secondary-theme rounded-lg space-y-3">
                                <h4 class="text-lg font-semibold border-b pb-2 mb-2">Agendamento de Lançamento (Em Breve)</h4>
                                <div class="flex space-x-4 items-center">
                                    <input type="checkbox" id="is-upcoming" class="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500">
                                    <label for="is-upcoming" class="text-sm font-medium">Agendar lançamento (Publicar em "Em Breve")</label>
                                </div>
                                <div id="release-date-time" class="grid grid-cols-2 gap-4 hidden pt-2">
                                    <div>
                                        <label for="release-date" class="block text-xs font-medium mb-1">Data de Lançamento</label>
                                        <input type="date" id="release-date" class="input-style" value="">
                                    </div>
                                    <div>
                                        <label for="release-time" class="block text-xs font-medium mb-1">Hora de Lançamento (Opcional)</label>
                                        <input type="time" id="release-time" class="input-style" value="">
                                    </div>
                                </div>
                            </div>
                            
                            <div>
                                <label for="title" class="block text-sm font-medium mb-1">Título</label>
                                <input type="text" id="title" class="input-style" required>
                            </div>
                            <div>
                                <label for="synopsis" class="block text-sm font-medium mb-1">Sinopse</label>
                                <textarea id="synopsis" rows="4" class="input-style" required></textarea>
                            </div>
                            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                                <div>
                                    <label for="release-year" class="block text-sm font-medium mb-1">Ano de Lançamento</label>
                                    <input type="text" id="release-year" class="input-style" required>
                                </div>
                                <div class="sm:col-span-2">
                                    <label for="genres" class="block text-sm font-medium mb-1">Gêneros</label>
                                    <input type="text" id="genres" class="input-style" required>
                                </div>
                            </div>
                            <div>
                                <label for="actors" class="block text-sm font-medium mb-1">Atores Principais</label>
                                <input type="text" id="actors" class="input-style" required>
                            </div>

                            <div id="dynamic-fields">
                                </div>
                            
                            <button type="submit" id="publish-submit-btn" class="w-full py-3 mt-8 bg-green-600 text-white font-bold rounded-lg shadow-md hover:bg-green-700 transition duration-300 flex items-center justify-center space-x-2" disabled>
                                <span id="publish-text">Publicar Conteúdo</span>
                                <span id="loading-spinner" class="hidden spinner"></span>
                            </button>
                        </form>
                    </div>

                    <div id="quick-publish-area" class="w-full max-w-4xl p-6 bg-secondary-theme/50 rounded-xl shadow-lg hidden">
                        <h3 class="text-2xl font-bold border-b pb-3 mb-6 text-purple-600">Publicação Rápida de Filmes</h3>
                        <p class="mb-4 opacity-80">Busque e selecione até 10 filmes do TMDB para postar de uma vez. Apenas a URL do link principal será necessária para cada um.</p>
                        
                        <div class="relative w-full mb-6">
                            <input type="text" id="quick-tmdb-search-input" class="input-style pr-10" placeholder="🔍 Buscar 10 filmes no TMDB">
                            <div id="quick-tmdb-results" class="absolute z-10 w-full mt-1 rounded-lg shadow-lg bg-secondary-theme border border-gray-300 dark:border-gray-700 max-h-60 overflow-y-auto hidden">
                                </div>
                        </div>

                        <form id="quick-publish-form" class="space-y-6">
                            <div id="quick-content-list" class="space-y-4">
                                <p class="text-center opacity-70">Selecione até 10 filmes na busca acima.</p>
                            </div>
                             
                            <div id="quick-publish-schedule-fields" class="p-4 bg-secondary-theme rounded-lg space-y-3 hidden">
                                <h4 class="text-lg font-semibold border-b pb-2 mb-2">Agendamento (Opcional - Todos os Filmes)</h4>
                                <div class="flex space-x-4 items-center">
                                    <input type="checkbox" id="quick-is-upcoming" class="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500">
                                    <label for="quick-is-upcoming" class="text-sm font-medium">Agendar lançamento (Publicar em "Em Breve")</label>
                                </div>
                                <div id="quick-release-date-time" class="grid grid-cols-2 gap-4 hidden pt-2">
                                    <div>
                                        <label for="quick-release-date" class="block text-xs font-medium mb-1">Data de Lançamento</label>
                                        <input type="date" id="quick-release-date" class="input-style" value="">
                                    </div>
                                    <div>
                                        <label for="quick-release-time" class="block text-xs font-medium mb-1">Hora de Lançamento (Opcional)</label>
                                        <input type="time" id="quick-release-time" class="input-style" value="">
                                    </div>
                                </div>
                            </div>


                            <button type="submit" id="quick-publish-submit-btn" class="w-full py-3 mt-8 bg-purple-600 text-white font-bold rounded-lg shadow-md hover:bg-purple-700 transition duration-300 flex items-center justify-center space-x-2" disabled>
                                <span id="quick-publish-text">Publicar 0 Filmes</span>
                                <span id="quick-loading-spinner" class="hidden spinner"></span>
                            </button>
                        </form>
                    </div>


                    <div id="edit-panel" class="hidden h-full flex flex-col items-center py-24">
                        <h3 class="text-2xl font-bold mb-6">Lista de Conteúdo para Edição</h3>
                        <div class="w-full max-w-4xl">
                            <div id="content-list-container" class="space-y-4">
                                <div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Carregando conteúdo...</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="feedbacks-panel" class="hidden h-full flex flex-col items-center py-24">
                        <h3 class="text-2xl font-bold mb-6 text-red-600">Feedbacks de Usuários</h3>
                        <div class="w-full max-w-4xl">
                            <div id="feedbacks-list-container" class="space-y-4">
                                <div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Carregando feedbacks...</div>
                            </div>
                        </div>
                    </div>

                    <div id="upcoming-admin-panel" class="hidden h-full flex flex-col items-center py-24">
                         <h3 class="text-2xl font-bold mb-6 text-yellow-600">Conteúdo Agendado ("Em Breve")</h3>
                         <div class="w-full max-w-4xl">
                            <div id="upcoming-admin-list-container" class="space-y-4">
                                <div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Carregando agendamentos...</div>
                            </div>
                            <p class="text-sm opacity-60 text-center mt-4">Conteúdo aqui só aparece no feed principal após a data de lançamento.</p>
                        </div>
                    </div>

                </div>

                <div id="explore-panel" class="hidden"></div>
                
                <div id="upcoming-panel" class="hidden">
                    <div id="upcoming-hero-banner-container" class="mb-8">
                        </div>
                    <div id="upcoming-carousels-container" class="space-y-12">
                        </div>
                    <div class="text-center pt-24 pb-8" id="upcoming-empty-message" style="display: none;">
                        <p class="text-xl opacity-80">Nenhum conteúdo agendado ainda.</p>
                    </div>
                </div>

            </div>
        </main>

    </div>
    
    <script type="module">
        // Variável de Versão
        const APP_VERSION = '2.4.0'; // Versão atualizada

        // --- 0. Firebase Setup (Inicialização) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, deleteDoc, collection, onSnapshot, query, where, getDocs, orderBy, writeBatch, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Ativa o log de debug do Firestore
        // setLogLevel('Debug'); // Comentado para ambiente de produção/simulação

        // Configuração de Firebase (usando a configuração estática fornecida)
        const firebaseConfig = {
            apiKey: "AIzaSyD54l5_drC1h9mC1-gWOWBNFIPIHpYAEUw",
            authDomain: "cinerv-6d05a.firebaseapp.com",
            projectId: "cinerv-6d05a",
            storageBucket: "cinerv-6d05a.firebasestorage.app",
            messagingSenderId: "1094490418643",
            appId: "1:1094490418643:web:6fd9a9ac8886eb5cd99326"
        };

        const firebaseApp = initializeApp(firebaseConfig);
        const auth = getAuth(firebaseApp);
        const db = getFirestore(firebaseApp);
        
        let userId = null;
        // Simulação do appId para o caminho de coleção pública
        const appId = 'default-cinerave-app'; 
        const PUBLIC_CONTENT_COLLECTION_PATH = `artifacts/${appId}/public/data/content`;
        const NOTIFICATIONS_COLLECTION_PATH = `artifacts/${appId}/public/data/notifications`;
        const FEEDBACK_COLLECTION_PATH = `artifacts/${appId}/public/data/feedbacks`;
        const USER_PREFERENCES_COLLECTION_PATH = `artifacts/${appId}/public/data/user_preferences`; // Nova Coleção para rastrear o "Notificar-me"
        const DELETED_NOTIFS_COLLECTION_PATH = `artifacts/${appId}/public/data/deleted_notifications`; // Nova Coleção para histórico de exclusão
        
        const uidDisplay = document.getElementById('user-uid-display');
        
        let clientNotifications = []; // Armazena notificações recebidas localmente
        let deletedNotifications = []; // Armazena notificações excluídas (histórico)
        let clientFeedbacks = []; // Armazena feedbacks localmente

        // Dados do conteúdo
        let allContent = []; // Conteúdo completo do Firestore (Publicado + Em Breve)
        let publishedContent = []; // Conteúdo publicado (no ar)
        let upcomingContent = []; // Conteúdo agendado (em breve)
        let userUpcomingPreferences = {}; // Armazena IDs do conteúdo que o usuário marcou para notificar.

        // Autenticação Anônima e Listener de Estado
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                uidDisplay.textContent = user.uid;
                
                // INICIA OS LISTENERS DO FIRESTORE APÓS A AUTENTICAÇÃO
                await setupFirestoreListeners(); // Adicionado await
            } else {
                uidDisplay.textContent = "Tentando login anônimo...";
                try {
                    await signInAnonymously(auth);
                } catch (error) {
                    console.error("Erro ao fazer login anônimo:", error);
                    uidDisplay.textContent = "Erro de Auth";
                }
            }
        });
        
        // Função para carregar as preferências do usuário
        async function loadUserPreferences() {
            if (!userId) return;
            try {
                const docRef = doc(db, USER_PREFERENCES_COLLECTION_PATH, userId);
                const docSnap = await getDocs(query(collection(db, USER_PREFERENCES_COLLECTION_PATH), where("__name__", "==", userId)));
                if (!docSnap.empty) {
                     userUpcomingPreferences = docSnap.docs[0].data().upcoming_notifications || {};
                }
            } catch (error) {
                console.error("Erro ao carregar preferências do usuário:", error);
            }
        }
        
        // Função para atualizar as preferências do usuário (Notificar-me)
        async function updateUserPreference(contentId, shouldNotify) {
            if (!userId) {
                window.alert('Faça login (anônimo) para salvar suas preferências.');
                return;
            }
            try {
                const docRef = doc(db, USER_PREFERENCES_COLLECTION_PATH, userId);
                userUpcomingPreferences[contentId] = shouldNotify;
                await setDoc(docRef, { upcoming_notifications: userUpcomingPreferences }, { merge: true });
            } catch (error) {
                console.error("Erro ao salvar preferência:", error);
            }
        }


        // --- Variáveis Globais e Configurações de UI ---
        
        const body = document.body;
        const themeToggle = document.getElementById('theme-toggle');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');
        const sidebar = document.getElementById('sidebar');
        const menuToggle = document.getElementById('menu-toggle');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const navTabsContainer = document.getElementById('nav-tabs');
        const navTabs = document.querySelectorAll('.nav-tab');
        const defaultFeed = document.getElementById('default-feed');
        const adminPanel = document.getElementById('admin-panel');
        const adminButton = document.getElementById('admin-button');
        const carouselFeedContainer = document.getElementById('carousel-feed-container'); 
        const emptyMessage = document.getElementById('empty-message');
        const toggleGlobalNotifsBtn = document.getElementById('toggle-global-notifs');
        const heroBannerContainer = document.getElementById('hero-banner-container'); 
        const reportErrorBtn = document.getElementById('report-error-btn'); // Botão Reportar na sidebar

        // NOVOS ELEMENTOS DA SIDEBAR
        const legalNoticeModal = document.getElementById('legal-notice-modal');
        const legalNoticeBtn = document.getElementById('legal-notice-btn');
        const closeLegalNoticeBtn = document.getElementById('close-legal-notice-btn');
        const toggleContinueWatchingBtn = document.getElementById('toggle-continue-watching');
        const continueWatchingText = document.getElementById('continue-watching-text');
        
        // Elementos do Link Copiável
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const linkText = document.getElementById('link-text');


        const navPublicar = document.getElementById('nav-publicar');
        const navEditar = document.getElementById('nav-editar');
        const navFeedbacks = document.getElementById('nav-feedbacks'); 
        const navPublicarRapida = document.getElementById('nav-publicar-rapida'); // NOVO
        const publishArea = document.getElementById('publish-area');
        const quickPublishArea = document.getElementById('quick-publish-area'); // NOVO
        const editPanel = document.getElementById('edit-panel');
        const feedbacksPanel = document.getElementById('feedbacks-panel'); 
        const explorePanel = document.getElementById('explore-panel');
        const upcomingPanel = document.getElementById('upcoming-panel'); // NOVO
        const upcomingEmptyMessage = document.getElementById('upcoming-empty-message'); // NOVO
        const upcomingCarouselsContainer = document.getElementById('upcoming-carousels-container'); // NOVO
        const upcomingHeroBannerContainer = document.getElementById('upcoming-hero-banner-container'); // NOVO
        const upcomingAdminListContainer = document.getElementById('upcoming-admin-list-container'); // NOVO
        
        const publishSubmitBtn = document.getElementById('publish-submit-btn');
        const publishText = document.getElementById('publish-text');
        const loadingSpinner = document.getElementById('loading-spinner');
        const contentDocIdInput = document.getElementById('content-doc-id');
        const contentListContainer = document.getElementById('content-list-container');
        const feedbacksListContainer = document.getElementById('feedbacks-list-container'); 
        const exitAdminBtn = document.getElementById('exit-admin-btn');
        
        // Elementos de Agendamento (Novo)
        const isUpcomingCheckbox = document.getElementById('is-upcoming');
        const releaseDateTimeContainer = document.getElementById('release-date-time');
        const releaseDateInput = document.getElementById('release-date');
        const releaseTimeInput = document.getElementById('release-time');
        const scheduleFields = document.getElementById('schedule-fields');
        
        // Elementos do Novo Modal de Detalhes
        const detailModal = document.getElementById('content-detail-modal');
        const closeDetailModalBtn = document.getElementById('close-detail-modal-btn');
        const detailHeader = document.getElementById('detail-header');
        const detailTitle = document.getElementById('detail-title');
        const detailTitleHeader = document.getElementById('detail-title-header'); // Novo para o título do header
        const detailTypeYear = document.getElementById('detail-type-year');
        const detailGenres = document.getElementById('detail-genres');
        const detailSynopsis = document.getElementById('detail-synopsis');
        const detailActors = document.getElementById('detail-actors');
        const mainWatchBtn = document.getElementById('main-watch-btn');
        const watchBtnText = document.getElementById('watch-btn-text');
        const watchIcon = document.getElementById('watch-icon');
        const seriesLinksPanel = document.getElementById('series-links-panel');
        const seasonsLinksContainer = document.getElementById('seasons-links-container');
        const seriesSeasonsBadge = document.getElementById('series-seasons-badge');
        const upcomingBadge = document.getElementById('upcoming-badge'); // NOVO
        const similarContentContainer = document.getElementById('similar-content-container'); // NOVO
        const similarContentPanel = document.getElementById('similar-content-panel'); // NOVO
        const noSimilarContent = document.getElementById('no-similar-content'); // NOVO

        // Elementos do Modal de Feedback
        const feedbackModal = document.getElementById('feedback-modal');
        const feedbackForm = document.getElementById('feedback-form');
        const feedbackCancelBtn = document.getElementById('feedback-cancel-btn');
        const feedbackSubmitBtn = document.getElementById('feedback-submit-btn');
        const feedbackSubmitText = document.getElementById('feedback-submit-text');
        const feedbackLoadingSpinner = document.getElementById('feedback-loading-spinner');
        
        // Elementos de Publicação Rápida
        const quickTmdbSearchInput = document.getElementById('quick-tmdb-search-input'); // NOVO
        const quickTmdbResults = document.getElementById('quick-tmdb-results'); // NOVO
        const quickContentListContainer = document.getElementById('quick-content-list'); // NOVO
        const quickPublishForm = document.getElementById('quick-publish-form'); // NOVO
        const quickPublishSubmitBtn = document.getElementById('quick-publish-submit-btn'); // NOVO
        const quickPublishText = document.getElementById('quick-publish-text'); // NOVO
        const quickLoadingSpinner = document.getElementById('quick-loading-spinner'); // NOVO
        const quickIsUpcomingCheckbox = document.getElementById('quick-is-upcoming'); // NOVO
        const quickReleaseDateTimeContainer = document.getElementById('quick-release-date-time'); // NOVO
        const quickReleaseDateInput = document.getElementById('quick-release-date'); // NOVO
        const quickReleaseTimeInput = document.getElementById('quick-release-time'); // NOVO
        const quickPublishScheduleFields = document.getElementById('quick-publish-schedule-fields'); // NOVO
        
        let selectedQuickPublishItems = []; // Array para o modo de publicação rápida
        
        const ADMIN_PASSWORD = 'leoleo';
        let isAdminMode = false;
        let contentType = 'movie'; // 'movie' ou 'series'
        let currentAdminView = 'publicar'; // 'publicar' ou 'publicar-rapida' ou 'editar' ou 'feedbacks'
        let currentActivePage = 'inicio';
        let currentFilters = { sort: 'popularidade', decade: 'todas', genre: 'todos' };
        
        let bannerInterval; // Intervalo para o banner rotativo
        let currentBannerIndex = 0; // Índice atual do banner

        // Lógica Continue Assistindo
        const VIEWED_CONTENT_KEY = 'cinerave_viewed_content';
        const isContinueWatchingHiddenKey = 'cinerave_hide_continue_watching';
        let isContinueWatchingHidden = localStorage.getItem(isContinueWatchingHiddenKey) === 'true';

        // Lógica de visualização de episódios
        const WATCHED_EPISODES_KEY = 'cinerave_watched_episodes';
        let watchedEpisodes = JSON.parse(localStorage.getItem(WATCHED_EPISODES_KEY) || '{}');
        
        // Lógica de Notificações Deletadas
        const DELETED_NOTIFS_KEY = 'cinerave_deleted_notifs';
        let localDeletedNotifs = JSON.parse(localStorage.getItem(DELETED_NOTIFS_KEY) || '[]');
        
        // Lógica de Notificação do Usuário (Local Storage para UX rápida)
        const UPCOMING_PREFS_KEY = 'cinerave_upcoming_notifs';
        let localUpcomingPrefs = JSON.parse(localStorage.getItem(UPCOMING_PREFS_KEY) || '{}');

        // TMDB Config
        const TMDB_API_KEY = 'd0f7e2c414b1efff7b000ae9b681ed1b';
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const TMDB_IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/w500';

        // Gêneros estáticos (para a aba Explorar)
        const GENRES = [
            'Ação', 'Aventura', 'Animação', 'Comédia', 'Crime', 'Documentário',
            'Drama', 'Família', 'Fantasia', 'História', 'Terror', 'Música',
            'Mistério', 'Romance', 'Ficção científica', 'Cinema TV', 'Thriller',
            'Guerra', 'Faroeste', 'LGBT', 'Novelas', 'Doramas', 'Reality Show' // Adicionado
        ];
        
        const DECADAS = [
            'Todas', 'Anos 2020', 'Anos 2010', 'Anos 2000', 'Anos 90', 'Anos 80', 'Anos 70', 'Anos 60', 'Anos 50', 'Anos 40', 'Anos 30'
        ];

        // Exibe a versão
        document.getElementById('app-version-display').textContent = `Versão ${APP_VERSION}`;

        // --- 2. Lógica do Tema (Dark/Light) ---

        function applyTheme(theme) {
            localStorage.setItem('theme', theme);
            if (theme === 'dark') {
                body.classList.add('dark');
                sunIcon.classList.remove('hidden'); 
                moonIcon.classList.add('hidden'); 
            } else {
                body.classList.remove('dark');
                sunIcon.classList.add('hidden'); 
                moonIcon.classList.remove('hidden'); 
            }
        }
        
        function toggleTheme() {
            const currentTheme = localStorage.getItem('theme') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else {
            applyTheme('light');
        }
        
        themeToggle.addEventListener('click', toggleTheme);

        // --- 3. Lógica do Menu Lateral (Sidebar) ---

        function toggleSidebar() {
            const isHidden = sidebar.classList.contains('-translate-x-full');
            if (isHidden) {
                sidebar.classList.remove('-translate-x-full');
                sidebarOverlay.classList.remove('opacity-0', 'pointer-events-none');
                sidebarOverlay.classList.add('opacity-50');
            } else {
                sidebar.classList.add('-translate-x-full');
                sidebarOverlay.classList.add('opacity-0', 'pointer-events-none');
                sidebarOverlay.classList.remove('opacity-50');
            }
        }

        menuToggle.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', toggleSidebar);

        window.addEventListener('resize', () => {
            if (window.innerWidth >= 1024) {
                sidebar.classList.remove('-translate-x-full');
                sidebarOverlay.classList.add('opacity-0', 'pointer-events-none');
            }
        });
        
        // --- 4. Lógica de Navegação (Tabs Comuns) ---

        function renderPage(pageKey) {
            if (isAdminMode) return;
            currentActivePage = pageKey;
            
            // Fecha o modal de notificações globais ao mudar de página
            if (globalNotifsModal.classList.contains('active')) {
                toggleGlobalNotifications();
            }

            explorePanel.classList.add('hidden');
            upcomingPanel.classList.add('hidden');
            defaultFeed.classList.add('hidden');
            
            // Gerencia o Banner Rotativo
            clearInterval(bannerInterval);
            heroBannerContainer.classList.add('hidden');
            upcomingHeroBannerContainer.classList.add('hidden');
            
            let contentToRender = [];
            let bannerContent = [];

            if (pageKey === 'explorar') {
                explorePanel.classList.remove('hidden');
                renderExploreContent();
            } else if (pageKey === 'upcoming') {
                upcomingPanel.classList.remove('hidden');
                contentToRender = upcomingContent;
                bannerContent = upcomingContent.filter(c => c.poster_url);
                startBannerRotation(upcomingHeroBannerContainer, bannerContent, true);
                renderUpcomingContent();
            } else {
                defaultFeed.classList.remove('hidden');
                
                // Filtra o conteúdo já lançado
                contentToRender = publishedContent;
                
                if (pageKey === 'inicio') {
                    bannerContent = publishedContent.filter(c => c.type === 'movie' && c.poster_url); // Apenas Filmes no Início
                } else if (pageKey === 'series') {
                    bannerContent = publishedContent.filter(c => c.type === 'series' && c.poster_url); // Apenas Séries na aba Séries
                }
                
                startBannerRotation(heroBannerContainer, bannerContent, false);
                renderFeedContent(pageKey, contentToRender); 
            }

            navTabs.forEach(tab => {
                tab.classList.remove('bg-accent-theme', 'text-white');
                if (tab.dataset.page === pageKey) {
                    tab.classList.add('bg-accent-theme', 'text-white');
                }
            });

            if (window.innerWidth < 1024 && !sidebar.classList.contains('-translate-x-full')) {
                toggleSidebar();
            }
        }
        
        navTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                renderPage(tab.dataset.page);
            });
        });
        
        // Função de renderização do Feed Principal (Início e Séries)
        function renderFeedContent(pageKey, content = publishedContent) {
            carouselFeedContainer.innerHTML = ''; // Limpa o feed
            
            if (content.length === 0) {
                emptyMessage.style.display = 'block';
                return;
            } else {
                emptyMessage.style.display = 'none';
            }
            
            // Função utilitária para checar se algum gênero está contido (case insensitive e trim)
            const hasGenre = (item, genresToMatch) => {
                const itemGenres = item.genres.map(g => g.trim().toLowerCase());
                return genresToMatch.some(g => itemGenres.includes(g.trim().toLowerCase()));
            };
            
            const allMovies = content.filter(c => c.type === 'movie');
            const allSeries = content.filter(c => c.type === 'series');
            
            // 1. Definição dos Carrosséis de Gênero (Múltiplas Sessões)
            // NOVO: Coleta todos os gêneros únicos e cria um carrossel para cada um que tenha pelo menos 5 itens
            const allGenres = [...new Set(content.flatMap(c => c.genres.map(g => g.trim())))];
            const dynamicCarousels = allGenres.map(genre => ({
                 title: `${genre} em Destaque`, 
                 genres: [genre]
            })).filter(c => content.filter(item => hasGenre(item, c.genres)).length >= 5);
            
            // Ordem de exibição dos carrosséis
            const carouselOrder = [
                { title: 'Adicionados Recentemente', type: 'recentes', filter: content }, // Sempre primeiro
                { title: 'Continue Assistindo', type: 'continue', filter: [] }, // Se for série e não estiver oculto
                ...dynamicCarousels // Carrosséis dinâmicos
            ];
            
            // Adiciona o carrossel de continue assistindo se as condições forem atendidas
            if (pageKey === 'series' && !isContinueWatchingHidden) {
                 const viewedContent = JSON.parse(localStorage.getItem(VIEWED_CONTENT_KEY) || '[]');
                 const availableViewed = viewedContent
                     .filter(v => v.type === 'series') 
                     .map(v => allSeries.find(p => p.id === v.id))
                     .filter(c => c);
                 
                 const continueWatchingCarousel = carouselOrder.find(c => c.type === 'continue');
                 if (continueWatchingCarousel) {
                      continueWatchingCarousel.filter = availableViewed;
                      if (availableViewed.length > 0) {
                          // Usa prepend para garantir que seja a primeira seção (depois dos recentes)
                          // Vamos simplificar e deixar na ordem
                      }
                 }
            }


            // Renderiza os carrosséis em ordem
            carouselOrder.forEach(carousel => {
                 let filteredContent = carousel.filter;
                 let title = carousel.title;
                 let id = title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                 
                 if (carousel.type === 'recentes') {
                     // Filtra por tipo de página e ordena por data
                     filteredContent = content.filter(c => pageKey === 'inicio' ? true : c.type === 'series').sort((a, b) => b.updatedAt - a.updatedAt);
                     title = pageKey === 'series' ? 'Séries Adicionadas Recentemente' : 'Adicionados Recentemente';
                 } else if (carousel.type === 'continue' && pageKey !== 'series') {
                     // Ignora 'Continue Assistindo' se não for a página de séries
                     return; 
                 } else if (carousel.type === 'continue') {
                     if (filteredContent.length === 0) return; // Se não houver nada, não renderiza
                 } else {
                     // Carrosséis dinâmicos de gênero
                     filteredContent = content.filter(c => (pageKey === 'inicio' ? true : c.type === 'series') && hasGenre(c, carousel.genres));
                     if (filteredContent.length === 0) return;
                 }
                 
                 if (filteredContent.length > 0) {
                      createCarousel(carouselFeedContainer, filteredContent, title, id, carousel.type === 'continue');
                 }
            });
        }
        
        // Função de renderização para a aba "Em Breve" (NOVO)
        function renderUpcomingContent() {
             upcomingCarouselsContainer.innerHTML = '';
             
             if (upcomingContent.length === 0) {
                 upcomingEmptyMessage.style.display = 'block';
                 return;
             } else {
                 upcomingEmptyMessage.style.display = 'none';
             }
             
             // Função utilitária para checar se algum gênero está contido (case insensitive e trim)
             const hasGenre = (item, genresToMatch) => {
                 const itemGenres = item.genres.map(g => g.trim().toLowerCase());
                 return genresToMatch.some(g => itemGenres.includes(g.trim().toLowerCase()));
             };

             // 1. Adicionados Recentemente
             const recentUpcoming = upcomingContent.sort((a, b) => b.updatedAt - a.updatedAt);
             createCarousel(upcomingCarouselsContainer, recentUpcoming, 'Agendados Recentemente', 'upcoming-recentes', false, true); // Último param é isUpcoming
             
             // 2. Carrosséis de Gênero (Dinâmicos)
             const allGenres = [...new Set(upcomingContent.flatMap(c => c.genres.map(g => g.trim())))];
             const dynamicCarousels = allGenres.map(genre => ({
                  title: `${genre} Em Breve`, 
                  genres: [genre]
             })).filter(c => upcomingContent.filter(item => hasGenre(item, c.genres)).length >= 3);
             
             dynamicCarousels.forEach(carousel => {
                 const filteredContent = upcomingContent.filter(c => hasGenre(c, carousel.genres));
                 if (filteredContent.length > 0) {
                     const id = carousel.title.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                     createCarousel(upcomingCarouselsContainer, filteredContent, carousel.title, id, false, true);
                 }
             });
        }


        // Função para criar um carrossel de posters (Melhorada para upcoming)
        function createCarousel(containerElement, contentArray, title, id, prepend = false, isUpcoming = false) {
             if (contentArray.length === 0) return;

             const carouselSection = document.createElement('section');
             carouselSection.className = 'carousel-section';
             
             carouselSection.innerHTML = `
                 <h2 class="text-xl font-bold mb-4">${title}</h2>
                 <div id="${id}-carousel" class="horizontal-scroll-container flex">
                     </div>
             `;
             
             if (prepend) {
                 containerElement.prepend(carouselSection);
             } else {
                 containerElement.appendChild(carouselSection);
             }

             const container = document.getElementById(`${id}-carousel`);
             
             contentArray.forEach(content => {
                 const posterDiv = document.createElement('div');
                 posterDiv.className = 'carousel-item poster-card';
                 posterDiv.style.backgroundImage = `url(${content.poster_url})`;
                 posterDiv.dataset.contentId = content.id; 

                 posterDiv.addEventListener('click', () => showDetailModal(content));
                 
                 // Selo de temporadas (apenas séries)
                 let badgeHTML = '';
                 if (content.type === 'series' && content.seasons?.length > 0) {
                     const count = content.seasons.length;
                     badgeHTML = `<span class="release-badge bg-blue-500 top-2 right-2">${count}ª Temp.</span>`;
                 } else if (isUpcoming) {
                     // Selo Em Breve (apenas no carrossel de Em Breve)
                      badgeHTML = `<span class="release-badge bg-yellow-500 text-black top-2 right-2">Em Breve</span>`;
                 }

                 // Nome do item no topo para melhor identificação no carrossel
                 posterDiv.innerHTML = `
                      ${badgeHTML}
                      <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/30 to-transparent flex items-end p-2 opacity-0 hover:opacity-100 transition duration-300">
                          <p class="text-white text-xs font-semibold truncate w-full">${content.title}</p>
                      </div>
                 `;
                 
                 container.appendChild(posterDiv);
             });
        }


        // --- 4.1. Lógica do Banner Rotativo (Hero Banner) ---

        function startBannerRotation(container, contentArray, isUpcoming = false) {
            const rotatableContent = contentArray.filter(c => c.poster_url && (c.backdrop_url || c.poster_url)); // Filtra por capa
            
            if (bannerInterval) {
                clearInterval(bannerInterval);
            }
            
            if (rotatableContent.length === 0) {
                container.innerHTML = '';
                container.classList.add('hidden');
                return;
            }
            
            container.classList.remove('hidden');

            currentBannerIndex = 0;
            updateHeroBanner(container, rotatableContent, isUpcoming);

            bannerInterval = setInterval(() => {
                currentBannerIndex = (currentBannerIndex + 1) % rotatableContent.length;
                updateHeroBanner(container, rotatableContent, isUpcoming);
            }, 4000); // 4 segundos
        }

        function updateHeroBanner(container, contentArray, isUpcoming) {
            const content = contentArray[currentBannerIndex];
            
            // Tenta usar backdrop_url (capa horizontal), fallback para poster_url
            const imageUrl = content.backdrop_url || content.poster_url;
            
            // Determina o texto e a ação do botão
            let buttonText = isUpcoming ? 'Notificar-me' : 'Saiba Mais';
            const isUserInterested = localUpcomingPrefs[content.id];
            
            if (isUpcoming && isUserInterested) {
                 buttonText = 'Receber Notificação (✔)';
            }
            
            // NOVO: Badge de lançamento no banner
             let upcomingBadgeHTML = '';
             if (isUpcoming) {
                 const releaseDate = content.releaseTimestamp ? new Date(content.releaseTimestamp).toLocaleString('pt-BR') : 'Data não definida';
                 upcomingBadgeHTML = `
                     <p class="text-yellow-400 font-bold text-lg mb-2">Em Breve</p>
                     <p class="text-white/80 text-sm mb-4">Lançamento: ${releaseDate}</p>
                 `;
             }
            
            const bannerHTML = `
                <div id="current-hero-banner"
                     class="relative w-full h-64 sm:h-80 bg-cover bg-center rounded-xl shadow-2xl cursor-pointer overflow-hidden transition-all duration-500"
                     style="background-image: url(${imageUrl});">
                    
                    <div class="absolute inset-0 bg-gradient-to-r from-black/70 via-black/20 to-transparent"></div>

                    <div class="absolute bottom-0 left-0 p-6 max-w-lg">
                        ${upcomingBadgeHTML}
                        <h3 class="text-white text-3xl sm:text-4xl font-extrabold mb-1">${content.title}</h3>
                        <p class="text-white/80 text-sm mb-4 line-clamp-2">${content.synopsis}</p>
                        <button id="banner-action-btn-${content.id}" 
                                class="w-auto py-2 px-6 bg-red-600 text-white font-bold rounded-lg shadow-md hover:bg-red-700 transition duration-300 self-start">
                            ${buttonText}
                        </button>
                    </div>
                </div>
            `;
            container.innerHTML = bannerHTML;
            
            const currentBannerElement = document.getElementById('current-hero-banner');
            const actionBtn = document.getElementById(`banner-action-btn-${content.id}`);
            
            // Abre o modal ao clicar no banner inteiro
            currentBannerElement.addEventListener('click', (e) => {
                 if (e.target.id === `banner-action-btn-${content.id}` || e.target.closest(`#banner-action-btn-${content.id}`)) {
                      return; 
                 }
                 showDetailModal(content);
            });
            
            // Ação específica do botão
            actionBtn.addEventListener('click', (e) => {
                 e.stopPropagation(); 
                 if (isUpcoming) {
                      toggleUpcomingNotification(content.id);
                      // Simplesmente atualiza o banner para refletir o novo estado de notificação
                      setTimeout(() => updateHeroBanner(container, contentArray, isUpcoming), 300);
                 } else {
                      showDetailModal(content);
                 }
            });
        }
        
        // NOVO: Alterna a notificação do conteúdo Em Breve
        async function toggleUpcomingNotification(contentId) {
             const willNotify = !localUpcomingPrefs[contentId];
             localUpcomingPrefs[contentId] = willNotify;
             localStorage.setItem(UPCOMING_PREFS_KEY, JSON.stringify(localUpcomingPrefs));

             // Tenta sincronizar com o Firebase (para rastreamento no futuro)
             await updateUserPreference(contentId, willNotify);

             window.alert(willNotify 
                 ? "Notificação ativada! Você será avisado quando o conteúdo for lançado." 
                 : "Notificação desativada.");
        }


        // --- 5. Lógica do Painel Admin (Modal e Transição) ---

        const adminModal = document.getElementById('admin-modal');
        const modalContent = document.getElementById('modal-content');
        const adminPasswordInput = document.getElementById('admin-password');
        const passwordError = document.getElementById('password-error');
        const modalCancel = document.getElementById('modal-cancel');
        const modalConfirm = document.getElementById('modal-confirm');
        
        // Modal de Confirmação de Exclusão
        const deleteConfirmationModal = document.getElementById('delete-confirmation-modal');
        const deleteItemTitle = document.getElementById('delete-item-title');
        const deleteConfirmBtn = document.getElementById('delete-confirm-btn');
        const deleteCancelBtn = document.getElementById('delete-cancel-btn');
        let itemToDelete = null; // Armazena o objeto para exclusão (Conteúdo)
        let itemToDeleteId = null; // ID do item a ser excluído
        let itemToDeleteType = null; // 'content' or 'feedback'

        function showDeleteModal(content) {
            itemToDelete = content;
            itemToDeleteId = content.id;
            itemToDeleteType = 'content';
            deleteItemTitle.textContent = `o conteúdo "${content.title}"`;
            deleteConfirmationModal.classList.add('active');
        }

        function hideDeleteModal() {
            itemToDelete = null;
            itemToDeleteId = null;
            itemToDeleteType = null;
            deleteConfirmationModal.classList.remove('active');
        }
        
        // NOVO: Exibir modal de exclusão para Feedback
        window.promptDeleteFeedback = (docId) => {
            itemToDeleteId = docId;
            itemToDeleteType = 'feedback';
            deleteItemTitle.textContent = "este feedback";
            deleteConfirmationModal.classList.add('active');
        }
        
        // NOVO: Exibir modal de exclusão para Notificação (Histórico)
        window.promptDeleteNotif = (docId) => {
            itemToDeleteId = docId;
            itemToDeleteType = 'notif-history';
            deleteItemTitle.textContent = "esta notificação do histórico";
            deleteConfirmationModal.classList.add('active');
        }

        deleteCancelBtn.addEventListener('click', hideDeleteModal);
        deleteConfirmBtn.addEventListener('click', () => {
            if (itemToDeleteType === 'content' && itemToDelete) {
                // Exclusão de Conteúdo
                window.deleteContent(itemToDelete.id, itemToDelete.title, itemToDelete.poster_url, itemToDelete.type);
            } else if (itemToDeleteType === 'feedback' && itemToDeleteId) {
                // Exclusão de Feedback
                window.deleteFeedback(itemToDeleteId);
            } else if (itemToDeleteType === 'notif-history' && itemToDeleteId) {
                // Exclusão do Histórico de Notificação
                window.deleteNotificationFromHistory(itemToDeleteId);
            }
            hideDeleteModal();
        });


        function openModal() {
            adminModal.classList.remove('hidden');
            setTimeout(() => {
                modalContent.classList.remove('scale-95', 'opacity-0');
                modalContent.classList.add('scale-100', 'opacity-100');
            }, 10);
            adminPasswordInput.value = '';
            passwordError.classList.add('hidden');
        }

        function closeModal() {
            modalContent.classList.remove('scale-100', 'opacity-100');
            modalContent.classList.add('scale-95', 'opacity-0');
            
            setTimeout(() => {
                adminModal.classList.add('hidden');
            }, 300);
        }

        function enterAdminMode() {
            isAdminMode = true;
            navTabsContainer.classList.add('hidden');
            defaultFeed.classList.add('hidden');
            explorePanel.classList.add('hidden');
            upcomingPanel.classList.add('hidden');
            adminPanel.classList.remove('hidden');
            renderAdminView('publicar'); // Define 'Publicar' como default
            clearInterval(bannerInterval); // Para a rotação do banner
        }

        function exitAdminMode() {
            isAdminMode = false;
            navTabsContainer.classList.remove('hidden');
            adminPanel.classList.add('hidden');
            renderPage('inicio'); // Volta para a página inicial
        }
        
        exitAdminBtn.addEventListener('click', exitAdminMode);


        function handleAdminLogin() {
            const password = adminPasswordInput.value;
            if (password === ADMIN_PASSWORD) {
                closeModal();
                enterAdminMode();
                if (window.innerWidth < 1024) {
                    toggleSidebar();
                }
            } else {
                passwordError.classList.remove('hidden');
                adminPasswordInput.focus();
            }
        }

        adminButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (isAdminMode) {
                exitAdminMode();
                if (window.innerWidth < 1024) {
                    toggleSidebar();
                }
            } else {
                openModal();
            }
        });
        
        modalCancel.addEventListener('click', closeModal);
        modalConfirm.addEventListener('click', handleAdminLogin);

        adminPasswordInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleAdminLogin();
            }
        });

        // --- 6. Lógica de Navegação Interna do Admin (ADICIONADO NOVO PAINEL) ---

        function renderAdminView(view) {
            currentAdminView = view;
            
            // Remove as classes de destaque/opacidade de todos os botões de navegação
            document.querySelectorAll('.admin-nav-btn').forEach(btn => {
                btn.classList.add('opacity-70', 'transform', 'hover:scale-[1.03]');
                btn.classList.remove('scale-100');
            });
            
            // Adiciona o destaque ao botão ativo
            const activeBtn = document.getElementById(`nav-${view}`);
            if (activeBtn) {
                activeBtn.classList.remove('opacity-70');
                activeBtn.classList.remove('hover:scale-[1.03]');
                activeBtn.classList.add('scale-100');
            }


            // Esconde todos os painéis
            publishArea.classList.add('hidden');
            quickPublishArea.classList.add('hidden'); // NOVO
            editPanel.classList.add('hidden');
            feedbacksPanel.classList.add('hidden'); 
            upcomingAdminListContainer.closest('.hidden')?.classList.add('hidden'); // Esconde o painel de agendamento (pai)
            
            // Limpa o formulário de publicação normal e o ID de edição ao trocar de aba (exceto edição para publicação)
             if (view !== 'publicar') {
                  contentDocIdInput.value = ''; // Sai do modo edição
                  setContentType(contentType); // Limpa/Reseta o formulário
             }
             
             // Limpa a lista de publicação rápida ao sair do painel
             if (view !== 'publicar-rapida') {
                 selectedQuickPublishItems = [];
                 renderQuickPublishList();
             }
            

            if (view === 'publicar') {
                publishArea.classList.remove('hidden');
                setContentType(contentType); 
            } else if (view === 'publicar-rapida') { // NOVO
                 quickPublishArea.classList.remove('hidden');
                 quickPublishScheduleFields.classList.add('hidden');
            } else if (view === 'editar') {
                editPanel.classList.remove('hidden');
                // Re-renderiza a lista de edições
                renderEditList(allContent.filter(c => !c.is_upcoming));
            } else if (view === 'upcoming-admin') { // NOVO
                 upcomingAdminListContainer.closest('.hidden')?.classList.remove('hidden');
                 renderUpcomingAdminList(upcomingContent);
            } else if (view === 'feedbacks') {
                feedbacksPanel.classList.remove('hidden');
            }
        }

        navPublicar.addEventListener('click', () => renderAdminView('publicar'));
        navPublicarRapida.addEventListener('click', () => renderAdminView('publicar-rapida')); // NOVO
        navEditar.addEventListener('click', () => renderAdminView('editar'));
        navFeedbacks.addEventListener('click', () => renderAdminView('feedbacks'));
        // Botão para o painel de conteúdo agendado
        // navAgendamento.addEventListener('click', () => renderAdminView('upcoming-admin')); // Adicionado na função de filtros


        // --- 7. Lógica do Formulário de Publicação (Filme/Série) ---

        const formTitle = document.getElementById('form-title');
        const contentTypeBtns = document.querySelectorAll('.content-type-btn');
        const dynamicFields = document.getElementById('dynamic-fields');
        const tmdbSearchInput = document.getElementById('tmdb-search-input');
        const tmdbResults = document.getElementById('tmdb-results');
        const posterPreview = document.getElementById('poster-preview');
        const form = document.getElementById('content-form');
        
        const fields = {
            title: document.getElementById('title'),
            synopsis: document.getElementById('synopsis'),
            releaseYear: document.getElementById('release-year'),
            genres: document.getElementById('genres'),
            actors: document.getElementById('actors'),
            isUpcoming: isUpcomingCheckbox, // NOVO
            releaseDate: releaseDateInput, // NOVO
            releaseTime: releaseTimeInput, // NOVO
            tmdbId: null,
            docId: contentDocIdInput, // Referência ao campo de ID
        };
        
        // Lógica de Agendamento (NOVO)
        isUpcomingCheckbox.addEventListener('change', () => {
             if (isUpcomingCheckbox.checked) {
                 releaseDateTimeContainer.classList.remove('hidden');
                 publishSubmitBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                 publishSubmitBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                 publishSubmitBtn.textContent = fields.docId.value ? 'Atualizar Agendamento' : 'Agendar Conteúdo';
             } else {
                 releaseDateTimeContainer.classList.add('hidden');
                 publishSubmitBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                 publishSubmitBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                 publishSubmitBtn.textContent = fields.docId.value ? 'Atualizar Conteúdo' : 'Publicar Conteúdo';
             }
        });
        
        // Função para limpar e configurar os campos
        function setContentType(type) {
            const isUpdate = !!fields.docId.value;
            contentType = type; // Atualiza a variável global

            formTitle.textContent = isUpdate 
                ? (type === 'movie' ? 'Editar Filme' : 'Editar Série') 
                : (type === 'movie' ? 'Adicionar Novo Filme' : 'Adicionar Nova Série');
            
            // Corrige o texto do botão com base no agendamento e modo de edição
            if (fields.isUpcoming.checked) {
                publishSubmitBtn.textContent = isUpdate ? 'Atualizar Agendamento' : 'Agendar Conteúdo';
            } else {
                publishSubmitBtn.textContent = isUpdate ? 'Atualizar Conteúdo' : 'Publicar Conteúdo';
            }
            
            // Se estamos mudando o TIPO e NÃO estamos no modo edição (apenas criando novo), limpamos os campos base.
            if (!isUpdate) {
                Object.values(fields).forEach(input => {
                     // Verifica se é um elemento DOM e se não é o docId
                    if (input && input.tagName !== undefined && input.id !== 'content-doc-id' && input.type !== 'checkbox') input.value = '';
                });
                fields.isUpcoming.checked = false;
                fields.tmdbId = null;
                tmdbSearchInput.value = '';
                tmdbResults.classList.add('hidden');
                posterPreview.innerHTML = 'Poster';
                posterPreview.style.backgroundImage = 'none';
                posterPreview.style.backgroundColor = '';
                
                // Reseta cores e texto do botão
                publishSubmitBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                publishSubmitBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                releaseDateTimeContainer.classList.add('hidden');
            }

            // Garante que o botão de tipo esteja destacado
            contentTypeBtns.forEach(btn => {
                btn.classList.remove('bg-accent-theme', 'text-white');
                if (btn.dataset.type === type) {
                    btn.classList.add('bg-accent-theme', 'text-white');
                }
            });
            
            // Renderiza os campos dinâmicos (vazios se não estiver em modo edição)
            renderDynamicFields();
            
            // Reabilita o botão se já houver TMDB ID, ou se estiver em edição
            if (fields.tmdbId || isUpdate) {
                publishSubmitBtn.disabled = false;
            } else {
                publishSubmitBtn.disabled = true;
            }
        }

        contentTypeBtns.forEach(btn => {
            btn.addEventListener('click', () => setContentType(btn.dataset.type));
        });

        // --- Geração de Campos Dinâmicos (Links / Temporadas) ---
        
        function renderDynamicFields() {
            dynamicFields.innerHTML = '';
            if (contentType === 'movie') {
                renderMovieLinksPanel();
            } else {
                renderSeriesSetupPanel();
            }
        }
        
        function renderMovieLinksPanel() {
            dynamicFields.innerHTML = `
                <h4 class="text-xl font-semibold mt-6 mb-4 border-b pb-2">Links (Manuais)</h4>
                <div id="movie-links-container" class="space-y-4">
                    </div>
                <button type="button" id="add-link-btn" class="mt-4 w-full py-2 px-4 rounded-lg bg-blue-500 text-white font-semibold hover:bg-blue-600 transition duration-200">
                    Adicionar Novo Link de Filme
                </button>
            `;
            document.getElementById('add-link-btn').addEventListener('click', addMovieLinkField);
            // Se não estivermos em modo edição, adiciona um link padrão
            if (!fields.docId.value) {
                addMovieLinkField();
            }
        }

        function createLinkField(linkData = {}, isEpisodeOne = false) {
            const linkField = document.createElement('div');
            linkField.className = 'p-4 rounded-lg bg-secondary-theme/80 flex flex-col space-y-3';
            
            // Se não for o primeiro episódio, esconde os inputs de qualidade e idioma para autocompletar.
            const hiddenClass = isEpisodeOne ? '' : ' hidden'; 

            linkField.innerHTML = `
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    <select class="input-style${hiddenClass}" name="qualidade" required ${isEpisodeOne ? '' : 'data-auto-filled="true" tabindex="-1"'}>
                        <option value="">Qualidade</option>
                        <option value="1080p" ${linkData.qualidade === '1080p' ? 'selected' : ''}>1080p (Full HD)</option>
                        <option value="720p" ${linkData.qualidade === '720p' ? 'selected' : ''}>720p (HD)</option>
                        <option value="480p" ${linkData.qualidade === '480p' ? 'selected' : ''}>480p (SD)</option>
                    </select>
                    <select class="input-style${hiddenClass}" name="idioma" required ${isEpisodeOne ? '' : 'data-auto-filled="true" tabindex="-1"'}>
                        <option value="">Idioma</option>
                        <option value="dublado" ${linkData.idioma === 'dublado' ? 'selected' : ''}>Dublado</option>
                        <option value="legendado" ${linkData.idioma === 'legendado' ? 'selected' : ''}>Legendado</option>
                        <option value="original" ${linkData.idioma === 'original' ? 'selected' : ''}>Original</option>
                    </select>
                    <input type="url" class="input-style" name="url" placeholder="URL do Link" value="${linkData.url || ''}" required>
                </div>
                <div class="flex justify-end">
                    <button type="button" class="remove-link-btn text-red-500 hover:text-red-700 p-1 rounded transition duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                    </button>
                </div>
            `;
            return linkField;
        }

        function addMovieLinkField(linkData = {}) {
            const container = document.getElementById('movie-links-container');
            const newLink = createLinkField(linkData, true); // Filmes sempre exibem os campos
            container.appendChild(newLink);
            newLink.querySelector('.remove-link-btn').addEventListener('click', () => {
                newLink.remove();
            });
        }
        
        function renderSeriesSetupPanel(seriesData = null) {
            dynamicFields.innerHTML = `
                <h4 class="text-xl font-semibold mt-6 mb-4 border-b pb-2">Configuração de Séries (Manual)</h4>
                <div class="mb-4">
                    <label for="num-seasons" class="block text-sm font-medium mb-1">Número de Temporadas</label>
                    <input type="number" id="num-seasons" min="1" value="${seriesData?.seasons?.length || 1}" class="input-style w-24" required>
                </div>
                <div id="seasons-container" class="space-y-8">
                    </div>
                <button type="button" id="add-season-btn" class="mt-6 py-2 px-4 rounded-lg bg-blue-500 text-white font-semibold hover:bg-blue-600 transition duration-200">
                    Adicionar Nova Temporada
                </button>
            `;
            
            const numSeasonsInput = document.getElementById('num-seasons');
            
            document.getElementById('add-season-btn').addEventListener('click', addManualSeasonPanel);
            
            numSeasonsInput.addEventListener('change', () => updateSeasonsBasedOnInput(seriesData));
            
            // Inicializa ou preenche com dados
            if (seriesData && seriesData.seasons && seriesData.seasons.length > 0) {
                seriesData.seasons.forEach(season => addSeasonPanel(season.number, season.episodes));
            } else {
                updateSeasonsBasedOnInput();
            }
        }
        
        function updateSeasonsBasedOnInput(seriesData = null) {
            const container = document.getElementById('seasons-container');
            const numSeasons = parseInt(document.getElementById('num-seasons').value) || 0;
            
            container.innerHTML = '';
            for (let i = 1; i <= numSeasons; i++) {
                const existingSeason = seriesData?.seasons?.find(s => s.number === i);
                addSeasonPanel(i, existingSeason?.episodes);
            }
            // Renumerar após reconstrução (garante ordem correta)
            renumberSeasons();
        }
        
        function addManualSeasonPanel() {
            const numSeasonsInput = document.getElementById('num-seasons');
            let currentNum = parseInt(numSeasonsInput.value) || 0;
            currentNum++;
            numSeasonsInput.value = currentNum;
            addSeasonPanel(currentNum);
        }
        
        // NOVO: Função para reenumerar temporadas e seus inputs/episódios
        function renumberSeasons() {
            const seasonPanels = document.querySelectorAll('#seasons-container > .season-panel');
            seasonPanels.forEach((panel, index) => {
                const newSeasonNum = index + 1;
                panel.dataset.seasonNum = newSeasonNum;
                panel.querySelector('h5').textContent = `Temporada ${newSeasonNum}`;
                
                const numEpisodesInput = panel.querySelector('.num-episodes-input');
                numEpisodesInput.dataset.season = newSeasonNum;
                
                const addEpisodeBtn = panel.querySelector('.add-episode-btn');
                addEpisodeBtn.dataset.season = newSeasonNum;

                // Renumerar episódios dentro da temporada (se for o caso)
                const episodeContainer = panel.querySelector('.episodes-container');
                const episodeFields = episodeContainer.querySelectorAll('.episode-field');
                
                episodeFields.forEach((epField, epIndex) => {
                    const newEpNum = epIndex + 1;
                    epField.querySelector('h6').textContent = `Episódio ${newEpNum}`;
                    
                    const isEpisodeOne = (newEpNum === 1);
                    const selectQualidade = epField.querySelector('[name="qualidade"]');
                    const selectIdioma = epField.querySelector('[name="idioma"]');

                    if (isEpisodeOne) {
                        selectQualidade.classList.remove('hidden');
                        selectIdioma.classList.remove('hidden');
                    } else if (selectQualidade.hasAttribute('data-auto-filled')) {
                        selectQualidade.classList.add('hidden');
                        selectIdioma.classList.add('hidden');
                    }
                });
            });
            document.getElementById('num-seasons').value = seasonPanels.length;
        }


        function addSeasonPanel(seasonNum, episodesData = []) {
            const container = document.getElementById('seasons-container');
            
            const seasonPanel = document.createElement('div');
            seasonPanel.className = 'season-panel p-5 border rounded-xl bg-secondary-theme space-y-4 relative';
            seasonPanel.dataset.seasonNum = seasonNum;
            
            const initialEpisodeCount = episodesData.length > 0 ? episodesData.length : 1;
            
            seasonPanel.innerHTML = `
                <div class="flex justify-between items-start">
                    <h5 class="text-lg font-bold">Temporada ${seasonNum}</h5>
                    <button type="button" class="remove-season-btn text-red-500 hover:text-red-700 p-1 rounded transition duration-200 ml-4 flex-shrink-0">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                    </button>
                </div>
                <div class="flex items-center space-x-4">
                    <label class="text-sm font-medium">Número de Episódios:</label>
                    <input type="number" min="1" value="${initialEpisodeCount}" class="num-episodes-input input-style w-24" data-season="${seasonNum}" required>
                </div>
                <div class="episodes-container space-y-3 border-t pt-4 mt-4" data-season="${seasonNum}">
                    </div>
                <button type="button" class="add-episode-btn py-1 px-3 rounded-lg bg-gray-500 text-white text-sm hover:bg-gray-600 transition duration-200" data-season="${seasonNum}">
                    Adicionar Novo Episódio Manualmente
                </button>
            `;
            container.appendChild(seasonPanel);
            
            seasonPanel.querySelector('.remove-season-btn').addEventListener('click', () => {
                removeSeason(seasonPanel);
            });

            const episodeContainer = seasonPanel.querySelector(`.episodes-container`);
            const numEpisodesInput = seasonPanel.querySelector('.num-episodes-input');
            const addEpisodeBtn = seasonPanel.querySelector('.add-episode-btn');

            const updateEpisodes = () => {
                const numEpisodes = parseInt(numEpisodesInput.value) || 0;
                
                // Salva a referência dos dados do EP 1 antes de limpar, se existirem
                const ep1LinkFields = episodeContainer.querySelector('.episode-field:first-child');
                const firstEpisodeLinkData = ep1LinkFields ? {
                    qualidade: ep1LinkFields.querySelector('[name="qualidade"]').value,
                    idioma: ep1LinkFields.querySelector('[name="idioma"]').value,
                    url: ep1LinkFields.querySelector('[name="url"]').value,
                } : {};


                episodeContainer.innerHTML = ''; // Limpa antes de reconstruir

                for (let i = 1; i <= numEpisodes; i++) {
                    const existingEpisode = episodesData.find(e => e.number === i);
                    const isEpisodeOne = (i === 1);
                    
                    let linkData = existingEpisode?.links?.[0] || {};
                    
                    if (!isEpisodeOne && Object.keys(linkData).length === 0) {
                         // Se não for o primeiro e não houver dados salvos, usa o que foi digitado no EP 1
                         linkData = firstEpisodeLinkData;
                    }

                    addEpisodeLinkField(episodeContainer, seasonNum, i, linkData, isEpisodeOne);
                }
                
                // Adiciona listeners para autocompletar no EP 1 se ele existir
                if (numEpisodes > 0) {
                    const ep1SelectQualidade = episodeContainer.querySelector('.episode-field [name="qualidade"]');
                    const ep1SelectIdioma = episodeContainer.querySelector('.episode-field [name="idioma"]');
                    
                    if (ep1SelectQualidade && ep1SelectIdioma) {
                        const updateRest = () => {
                            const qualidade = ep1SelectQualidade.value;
                            const idioma = ep1SelectIdioma.value;
                            
                            // Atualiza os inputs ocultos nos episódios subsequentes
                            episodeContainer.querySelectorAll('.episode-field').forEach((field, idx) => {
                                if (idx > 0) { // Ignora o primeiro episódio
                                    field.querySelector('[name="qualidade"]').value = qualidade;
                                    field.querySelector('[name="idioma"]').value = idioma;
                                }
                            });
                        };
                        
                        ep1SelectQualidade.addEventListener('change', updateRest);
                        ep1SelectIdioma.addEventListener('change', updateRest);
                    }
                }
            };

            numEpisodesInput.addEventListener('change', updateEpisodes);
            
            addEpisodeBtn.addEventListener('click', () => {
                let currentEpisodeCount = episodeContainer.children.length;
                currentEpisodeCount++;
                numEpisodesInput.value = currentEpisodeCount; 
                
                // Novo episódio manual (usa a lógica de autocompletar se EP1 existir)
                const ep1SelectQualidade = episodeContainer.querySelector('.episode-field [name="qualidade"]');
                const ep1SelectIdioma = episodeContainer.querySelector('.episode-field [name="idioma"]');

                let linkData = {};
                if (ep1SelectQualidade && ep1SelectIdioma) {
                    linkData = {
                        qualidade: ep1SelectQualidade.value,
                        idioma: ep1SelectIdioma.value,
                    };
                }

                // Adiciona o novo episódio
                addEpisodeLinkField(episodeContainer, seasonNum, currentEpisodeCount, linkData, false);
                renumberSeasons();
            });

            updateEpisodes();
            renumberSeasons();
        }

        function removeSeason(seasonPanel) {
            seasonPanel.remove();
            renumberSeasons(); // Renumera após a remoção
        }
        
        function removeEpisodeField(episodeField) {
            const seasonPanel = episodeField.closest('.season-panel');
            episodeField.remove();
            
            // Renumerar episódios restantes na temporada
            const episodeContainer = seasonPanel.querySelector('.episodes-container');
            const numEpisodesInput = seasonPanel.querySelector('.num-episodes-input');
            
            const episodeFields = episodeContainer.querySelectorAll('.episode-field');
            numEpisodesInput.value = episodeFields.length;
            
            episodeFields.forEach((epField, epIndex) => {
                 const newEpNum = epIndex + 1;
                 epField.querySelector('h6').textContent = `Episódio ${newEpNum}`;
                 
                 // Lógica para garantir que o NOVO EP 1 tenha os campos visíveis.
                 const isEpisodeOne = (newEpNum === 1);
                 const selectQualidade = epField.querySelector('[name="qualidade"]');
                 const selectIdioma = epField.querySelector('[name="idioma"]');

                 if (isEpisodeOne) {
                     selectQualidade.classList.remove('hidden');
                     selectIdioma.classList.remove('hidden');
                 } else if (selectQualidade.hasAttribute('data-auto-filled')) {
                     selectQualidade.classList.add('hidden');
                     selectIdioma.classList.add('hidden');
                 }
            });
            renumberSeasons(); // Chama o renumber global para garantir a contagem de temporadas
        }

        // Adiciona o parâmetro isEpisodeOne
        function addEpisodeLinkField(container, seasonNum, episodeNum, linkData = {}, isEpisodeOne = false) {
            const episodeField = document.createElement('div');
            episodeField.className = 'episode-field p-3 rounded-lg bg-secondary-theme/90 flex flex-col space-y-2 border';
            
            // Reutiliza o createLinkField e injeta os dados de link
            const linkField = createLinkField(linkData, isEpisodeOne);
            
            // Ajusta o botão de remover para chamar a função correta
            const removeButtonHTML = `<div class="flex justify-end pt-2">
                <button type="button" class="remove-episode-btn text-red-500 hover:text-red-700 p-1 rounded transition duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                </button>
            </div>`;
            
            // Remove o botão de link field original e adiciona o de episode field
            let linkFieldHTML = linkField.innerHTML;
            linkFieldHTML = linkFieldHTML.replace(/<div class="flex justify-end">[\s\S]*?<\/button>\s*<\/div>/, '');

            episodeField.innerHTML = `
                <h6 class="font-semibold text-sm">Episódio ${episodeNum}</h6>
                ${linkFieldHTML}
                ${removeButtonHTML}
            `;
            container.appendChild(episodeField);

            episodeField.querySelector('.remove-episode-btn').addEventListener('click', () => {
                removeEpisodeField(episodeField);
            });
        }


        // --- 8. Lógica de Busca TMDB --- (Mantida)
        
        async function fetchTMDB(endpoint, queryParams = {}) {
            const url = new URL(`${TMDB_BASE_URL}/${endpoint}`);
            url.searchParams.set('api_key', TMDB_API_KEY);
            url.searchParams.set('language', 'pt-BR'); 
            Object.keys(queryParams).forEach(key => url.searchParams.set(key, queryParams[key]));

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('Erro na API do TMDB');
                return response.json();
            } catch (error) {
                console.error("Erro ao buscar no TMDB:", error);
                return { results: [] };
            }
        }
        
        let searchTimeout;
        tmdbSearchInput.addEventListener('input', () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(searchTMDB, 500);
        });

        async function searchTMDB() {
            const query = tmdbSearchInput.value.trim();
            if (query.length < 3) {
                tmdbResults.classList.add('hidden');
                return;
            }

            const data = await fetchTMDB('search/multi', { query: query });
            
            tmdbResults.innerHTML = '';
            tmdbResults.classList.remove('hidden');

            const filteredResults = data.results.filter(
                item => (item.media_type === 'movie' || item.media_type === 'tv') && item.poster_path
            );
            
            if (filteredResults.length === 0) {
                tmdbResults.innerHTML = '<p class="p-3 text-sm opacity-70">Nenhum resultado encontrado.</p>';
                return;
            }

            filteredResults.slice(0, 8).forEach(item => {
                const title = item.media_type === 'movie' ? item.title : item.name;
                const releaseDate = item.media_type === 'movie' ? item.release_date : item.first_air_date;
                const year = releaseDate ? new Date(releaseDate).getFullYear() : 'N/A';
                
                const resultItem = document.createElement('div');
                resultItem.className = 'p-3 hover:bg-accent-theme/20 cursor-pointer border-b border-gray-300 dark:border-gray-700 last:border-b-0 flex space-x-3 items-center';
                resultItem.innerHTML = `
                    <img src="${TMDB_IMAGE_BASE_URL + item.poster_path}" alt="Poster" class="w-10 h-15 rounded-sm object-cover">
                    <div>
                        <p class="font-semibold text-sm">${title} (${year})</p>
                        <p class="text-xs opacity-70">${item.media_type === 'movie' ? 'Filme' : 'Série'}</p>
                    </div>
                `;
                resultItem.addEventListener('click', () => selectContent(item));
                tmdbResults.appendChild(resultItem);
            });
        }
        
        async function selectContent(item) {
            tmdbResults.classList.add('hidden');
            tmdbSearchInput.value = item.media_type === 'movie' ? item.title : item.name;
            
            const newType = item.media_type === 'movie' ? 'movie' : 'series';
            if (newType !== contentType) {
                // Se o tipo mudou, reinicia a lógica para o novo tipo
                fields.docId.value = ''; // Garante que não está em modo edição
                setContentType(newType); 
            }
            
            fields.tmdbId = item.id;
            
            const details = await fetchTMDB(`${item.media_type}/${item.id}`);
            const credits = await fetchTMDB(`${item.media_type}/${item.id}/credits`);
            const topActors = credits.cast
                .filter(a => a.known_for_department === 'Acting')
                .slice(0, 5)
                .map(a => a.name)
                .join(', ');
                
            const backdropUrl = details.backdrop_path ? `${TMDB_IMAGE_BASE_URL.replace('w500', 'original')}${details.backdrop_path}` : null;
                
            fields.title.value = item.media_type === 'movie' ? item.title : item.name;
            fields.synopsis.value = details.overview || item.overview || 'Sinopse não disponível.';
            fields.releaseYear.value = item.media_type === 'movie' 
                ? (details.release_date ? new Date(details.release_date).getFullYear() : 'N/A')
                : (details.first_air_date ? new Date(details.first_air_date).getFullYear() : 'N/A');
            fields.genres.value = details.genres ? details.genres.map(g => g.name).join(', ') : 'N/A';
            fields.actors.value = topActors || 'N/A';
            
            posterPreview.innerHTML = '';
            posterPreview.style.backgroundImage = `url(${TMDB_IMAGE_BASE_URL + item.poster_path})`;
            posterPreview.style.backgroundSize = 'cover';
            posterPreview.style.backgroundPosition = 'center';
            posterPreview.style.width = '96px';
            posterPreview.style.height = '144px';
            posterPreview.dataset.posterUrl = TMDB_IMAGE_BASE_URL + item.poster_path; // Salva o URL para o formulário
            posterPreview.dataset.backdropUrl = backdropUrl; // Salva a capa horizontal

            // Habilita o botão de publicação/edição após a seleção bem-sucedida
            publishSubmitBtn.disabled = false;
        }
        
        // --- 9. Lógica de Publicação/Edição Final (Firestore) ---
        
        // Função para preencher o formulário com dados existentes (para Edição)
        window.loadContentForEdit = (content) => {
            renderAdminView('publicar'); // Abre o painel de publicação
            
            const type = content.type;
            
            // Define o tipo antes de preencher os campos dinâmicos
            contentType = type;
            // Garante que os botões de tipo estejam corretos
            contentTypeBtns.forEach(btn => {
                btn.classList.remove('bg-accent-theme', 'text-white');
                if (btn.dataset.type === type) {
                    btn.classList.add('bg-accent-theme', 'text-white');
                }
            });

            // Preenche campos base
            fields.docId.value = content.id;
            fields.tmdbId = content.tmdb_id;
            fields.title.value = content.title;
            fields.synopsis.value = content.synopsis;
            fields.releaseYear.value = content.year;
            fields.genres.value = content.genres.join(', ');
            fields.actors.value = content.actors.join(', ');
            
            // NOVO: Preenche campos de Agendamento
            fields.isUpcoming.checked = content.is_upcoming || false;
            if (content.is_upcoming && content.releaseTimestamp) {
                const releaseDate = new Date(content.releaseTimestamp);
                fields.releaseDate.value = releaseDate.toISOString().substring(0, 10);
                fields.releaseTime.value = releaseDate.toTimeString().substring(0, 5);
                releaseDateTimeContainer.classList.remove('hidden');
                publishSubmitBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                publishSubmitBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                publishSubmitBtn.textContent = 'Atualizar Agendamento';
            } else {
                 fields.isUpcoming.checked = false;
                 releaseDateTimeContainer.classList.add('hidden');
                 publishSubmitBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
                 publishSubmitBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                 publishSubmitBtn.textContent = 'Atualizar Conteúdo';
            }


            publishSubmitBtn.disabled = false; // Garante que o botão esteja ativo na edição

            // Atualiza Poster
            posterPreview.innerHTML = '';
            posterPreview.style.backgroundImage = `url(${content.poster_url})`;
            posterPreview.style.backgroundSize = 'cover';
            posterPreview.style.backgroundPosition = 'center';
            posterPreview.style.width = '96px';
            posterPreview.style.height = '144px';
            posterPreview.dataset.posterUrl = content.poster_url;
            posterPreview.dataset.backdropUrl = content.backdrop_url || '';
            
            // Preenche campos dinâmicos (Links ou Séries)
            if (type === 'movie') {
                renderMovieLinksPanel(); // Renderiza o painel de links vazio
                const container = document.getElementById('movie-links-container');
                container.innerHTML = ''; // Limpa o default
                content.links.forEach(link => addMovieLinkField(link));
            } else if (type === 'series') {
                // Chamada de renderização da série com os dados.
                renderSeriesSetupPanel(content);
            }
        }
        
        // Função chamada pelo botão "Editar" na lista
        window.editContent = (docId) => {
            const content = allContent.find(c => c.id === docId);
            if (content) {
                window.loadContentForEdit(content);
                // Fecha a sidebar no mobile se estiver aberta
                if (window.innerWidth < 1024 && !sidebar.classList.contains('-translate-x-full')) {
                    toggleSidebar();
                }
            } else {
                console.error("Conteúdo não encontrado para edição:", docId);
            }
        }

        // Função para coletar os dados do formulário
        function collectFormData() {
            const data = {
                type: contentType,
                tmdb_id: fields.tmdbId,
                title: fields.title.value,
                synopsis: fields.synopsis.value,
                year: fields.releaseYear.value,
                genres: fields.genres.value.split(',').map(g => g.trim()).filter(g => g),
                actors: fields.actors.value.split(',').map(a => a.trim()).filter(a => a),
                poster_url: posterPreview.dataset.posterUrl || '', // Usa o dataset
                backdrop_url: posterPreview.dataset.backdropUrl || '', // Usa o dataset NOVO
                updatedAt: Date.now(),
                userId: userId,
                is_upcoming: fields.isUpcoming.checked, // NOVO
            };
            
            // Lógica de Agendamento (NOVO)
            if (data.is_upcoming) {
                 const releaseDate = fields.releaseDate.value;
                 const releaseTime = fields.releaseTime.value || '00:00'; // Padrão 00:00
                 
                 if (!releaseDate) { throw new Error('Se a opção "Em Breve" está marcada, a data de lançamento é obrigatória.'); }
                 
                 // Combina data e hora e armazena como Timestamp
                 const releaseDateTime = new Date(`${releaseDate}T${releaseTime}:00`);
                 data.releaseTimestamp = releaseDateTime.getTime();
                 
                 if (data.releaseTimestamp < Date.now()) {
                     throw new Error('A data de lançamento não pode ser no passado ao agendar.');
                 }
            } else {
                 data.releaseTimestamp = null;
            }
            
            if (contentType === 'movie') {
                data.links = [];
                document.querySelectorAll('#movie-links-container > div').forEach(linkField => {
                    const link = {
                        qualidade: linkField.querySelector('[name="qualidade"]').value,
                        idioma: linkField.querySelector('[name="idioma"]').value,
                        url: linkField.querySelector('[name="url"]').value,
                    };
                    if (link.qualidade && link.idioma && link.url) {
                        data.links.push(link);
                    }
                });
                if (data.links.length === 0) { throw new Error('Por favor, adicione pelo menos um link de filme.'); }
            } else if (contentType === 'series') {
                data.seasons = [];
                document.querySelectorAll('.season-panel').forEach((seasonPanel) => {
                    const seasonNum = parseInt(seasonPanel.dataset.seasonNum); 
                    const season = { number: seasonNum, episodes: [] };
                    
                    const episodeFields = seasonPanel.querySelectorAll('.episode-field');
                    
                    // 1. Obtém os valores de qualidade e idioma do PRIMEIRO episódio (que são visíveis)
                    const firstEpisodeField = episodeFields[0];
                    const defaultQualidade = firstEpisodeField ? firstEpisodeField.querySelector('[name="qualidade"]').value : '';
                    const defaultIdioma = firstEpisodeField ? firstEpisodeField.querySelector('[name="idioma"]').value : '';

                    // 2. Itera sobre todos os episódios para coletar links e aplicar os valores padrão
                    episodeFields.forEach((episodeField, eIndex) => {
                        
                        const linkData = {
                            // Usa os valores do primeiro episódio para QUALIDADE e IDIOMA
                            qualidade: defaultQualidade,
                            idioma: defaultIdioma,
                            url: episodeField.querySelector('[name="url"]').value,
                        };
                        
                        const episodeNumber = parseInt(episodeField.querySelector('h6').textContent.replace('Episódio ', ''));

                        if (linkData.qualidade && linkData.idioma && linkData.url) {
                            season.episodes.push({
                                number: episodeNumber, 
                                links: [linkData]
                            });
                        }
                    });

                    if (season.episodes.length > 0) {
                        data.seasons.push(season);
                    }
                });
                if (data.seasons.length === 0) { throw new Error('Por favor, adicione pelo menos uma temporada com episódios e links.'); }
            }
            return data;
        }
        
        function setPublishButtonState(loading, isUpdate = false, isUpcoming = false) {
            publishSubmitBtn.disabled = loading;
            
            let baseText = isUpdate ? 'Atualizar' : 'Publicar';
            if (isUpcoming) baseText = isUpdate ? 'Atualizar Agendamento' : 'Agendar';
            
            publishText.textContent = loading ? `${baseText}...` : `${baseText} Conteúdo`;
            
            if (loading) {
                loadingSpinner.classList.remove('hidden');
            } else {
                loadingSpinner.classList.add('hidden');
            }
        }


        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!fields.tmdbId) {
                window.alert('Por favor, selecione um conteúdo do TMDB antes de publicar/atualizar.');
                return;
            }
            
            const isUpdate = !!fields.docId.value;
            setPublishButtonState(true, isUpdate, fields.isUpcoming.checked); // Inicia o loading

            try {
                const contentData = collectFormData();
                const docId = fields.docId.value;
                let eventType;
                let finalDocRef;
                let isScheduled = contentData.is_upcoming;

                if (!isUpdate) {
                    // MODO PUBLICAÇÃO (CRIAÇÃO): Checa Duplicatas
                    const q = query(collection(db, PUBLIC_CONTENT_COLLECTION_PATH), where("tmdb_id", "==", contentData.tmdb_id));
                    const querySnapshot = await getDocs(q);
                    
                    if (!querySnapshot.empty) {
                        throw new Error("Este conteúdo (TMDB ID) já foi publicado. Use a aba 'Editar'.");
                    }
                    
                    // Publicação
                    finalDocRef = doc(collection(db, PUBLIC_CONTENT_COLLECTION_PATH));
                    contentData.createdAt = Date.now();
                    await setDoc(finalDocRef, contentData);
                    eventType = isScheduled ? 'agendado' : 'publicado';
                } else {
                    // MODO EDIÇÃO (ATUALIZAÇÃO)
                    finalDocRef = doc(db, PUBLIC_CONTENT_COLLECTION_PATH, docId);
                    await setDoc(finalDocRef, contentData, { merge: true });
                    eventType = isScheduled ? 'agendamento_atualizado' : 'atualizado';
                    
                    // Se estiver em modo agendamento, mas o conteúdo não estava antes, envia notificação de agendamento.
                    const existingContent = allContent.find(c => c.id === docId);
                    if (isScheduled && !existingContent?.is_upcoming) {
                        eventType = 'agendado';
                    }
                    // Se estava agendado e não está mais, força a notificação de publicado.
                    if (!isScheduled && existingContent?.is_upcoming) {
                         eventType = 'publicado';
                    }
                }
                
                // Dispara Notificação (somente se houver userId)
                if (userId && !isScheduled) { // Só notifica imediatamente se for publicado/atualizado (não agendado)
                    await sendNotification({
                        type: eventType,
                        title: contentData.title,
                        poster_url: contentData.poster_url,
                        item_type: contentData.type,
                        content_id: finalDocRef.id // Adiciona o ID do conteúdo
                    });
                } else if (userId && isScheduled) {
                    // Notificação de agendamento (apenas um aviso no admin se necessário)
                    console.log(`Conteúdo agendado: ${contentData.title}`);
                }

                window.alert(`Conteúdo (${contentData.title}) ${eventType.replace('_', ' ')} com sucesso!`);
                
                // Limpa formulário e navega para Edição
                fields.docId.value = ''; // Sai do modo edição
                setContentType(contentType); 
                renderAdminView('editar');

            } catch (error) {
                console.error("Erro durante a publicação/edição:", error);
                
                let errorMessage = 'Falha ao salvar o conteúdo.';
                if (error.code && error.code === 'permission-denied') {
                    errorMessage = 'ERRO DE PERMISSÃO: O Firebase está bloqueando a escrita. Por favor, verifique as Regras de Segurança do seu Firestore para permitir a escrita na coleção de conteúdo.';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                window.alert(`Erro: ${errorMessage}`);
            } finally {
                setPublishButtonState(false, isUpdate, fields.isUpcoming.checked); // Finaliza o loading
            }
        });

        // Excluir conteúdo (Inicia o modal de confirmação)
        window.promptDeleteContent = (docId) => {
            const content = allContent.find(c => c.id === docId);
            if (content) {
                showDeleteModal(content);
            }
        }
        
        // Execução real da exclusão de Conteúdo
        window.deleteContent = async (docId, title, poster_url, type) => {
            try {
                const contentRef = doc(db, PUBLIC_CONTENT_COLLECTION_PATH, docId);
                await deleteDoc(contentRef);
                
                // Dispara Notificação (somente se houver userId)
                if (userId) {
                    await sendNotification({
                        type: 'excluído',
                        title: title,
                        poster_url: poster_url,
                        item_type: type,
                        content_id: docId // Adiciona o ID do conteúdo
                    });
                }

                window.alert(`Conteúdo "${title}" excluído com sucesso do Firebase!`);
            } catch (error) {
                console.error("Erro ao excluir o conteúdo:", error);
                
                let errorMessage = 'Falha ao excluir o conteúdo.';
                if (error.code && error.code === 'permission-denied') {
                    errorMessage = 'ERRO DE PERMISSÃO: O Firebase está bloqueando a exclusão. Por favor, verifique as Regras de Segurança do seu Firestore.';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                window.alert(`Erro ao excluir: ${errorMessage}`);
            }
        };


        // --- NOVO: 9.1 Lógica de Publicação Rápida (Múltiplos Filmes) ---

        let quickSearchTimeout;
        quickTmdbSearchInput.addEventListener('input', () => {
             clearTimeout(quickSearchTimeout);
             quickSearchTimeout = setTimeout(searchQuickTMDB, 500);
        });
        
        // Lógica de Agendamento Rápido
        quickIsUpcomingCheckbox.addEventListener('change', () => {
             if (quickIsUpcomingCheckbox.checked) {
                 quickReleaseDateTimeContainer.classList.remove('hidden');
             } else {
                 quickReleaseDateTimeContainer.classList.add('hidden');
             }
        });

        async function searchQuickTMDB() {
            const query = quickTmdbSearchInput.value.trim();
            if (query.length < 3) {
                quickTmdbResults.classList.add('hidden');
                return;
            }

            const data = await fetchTMDB('search/movie', { query: query }); // Apenas filmes
            
            quickTmdbResults.innerHTML = '';
            quickTmdbResults.classList.remove('hidden');

            const filteredResults = data.results.filter(item => item.media_type === 'movie' && item.poster_path && !selectedQuickPublishItems.some(s => s.tmdb_id === item.id));
            
            if (filteredResults.length === 0) {
                quickTmdbResults.innerHTML = '<p class="p-3 text-sm opacity-70">Nenhum resultado encontrado.</p>';
                return;
            }

            filteredResults.slice(0, 8).forEach(item => {
                const year = item.release_date ? new Date(item.release_date).getFullYear() : 'N/A';
                
                const resultItem = document.createElement('div');
                resultItem.className = 'p-3 hover:bg-accent-theme/20 cursor-pointer border-b border-gray-300 dark:border-gray-700 last:border-b-0 flex space-x-3 items-center';
                resultItem.innerHTML = `
                    <img src="${TMDB_IMAGE_BASE_URL + item.poster_path}" alt="Poster" class="w-10 h-15 rounded-sm object-cover">
                    <div>
                        <p class="font-semibold text-sm">${item.title} (${year})</p>
                    </div>
                `;
                resultItem.addEventListener('click', () => addQuickPublishItem(item));
                quickTmdbResults.appendChild(resultItem);
            });
        }
        
        async function addQuickPublishItem(item) {
             if (selectedQuickPublishItems.length >= 10) {
                 window.alert('Limite máximo de 10 filmes selecionados atingido para a publicação rápida.');
                 return;
             }
             
             // Busca detalhes completos para obter sinopse, atores, etc.
             const details = await fetchTMDB(`movie/${item.id}`);
             const credits = await fetchTMDB(`movie/${item.id}/credits`);
             
             const topActors = credits.cast
                 .filter(a => a.known_for_department === 'Acting')
                 .slice(0, 5)
                 .map(a => a.name)
                 .join(', ');
                 
             const backdropUrl = details.backdrop_path ? `${TMDB_IMAGE_BASE_URL.replace('w500', 'original')}${details.backdrop_path}` : null;


             const newItem = {
                 tmdb_id: item.id,
                 title: item.title,
                 type: 'movie',
                 synopsis: details.overview || item.overview || 'Sinopse não disponível.',
                 year: details.release_date ? new Date(details.release_date).getFullYear().toString() : 'N/A',
                 genres: details.genres ? details.genres.map(g => g.name).filter(g => g) : [],
                 actors: topActors.split(',').map(a => a.trim()).filter(a => a),
                 poster_url: TMDB_IMAGE_BASE_URL + item.poster_path,
                 backdrop_url: backdropUrl,
                 link: '', // Será preenchido no formulário
             };
             
             selectedQuickPublishItems.push(newItem);
             
             quickTmdbSearchInput.value = '';
             quickTmdbResults.classList.add('hidden');
             
             renderQuickPublishList();
        }
        
        function removeQuickPublishItem(index) {
            selectedQuickPublishItems.splice(index, 1);
            renderQuickPublishList();
        }

        function renderQuickPublishList() {
            quickContentListContainer.innerHTML = '';
            quickPublishSubmitBtn.disabled = selectedQuickPublishItems.length === 0;
            quickPublishText.textContent = `Publicar ${selectedQuickPublishItems.length} Filme${selectedQuickPublishItems.length !== 1 ? 's' : ''}`;
            
            if (selectedQuickPublishItems.length === 0) {
                 quickContentListContainer.innerHTML = '<p class="text-center opacity-70">Selecione até 10 filmes na busca acima.</p>';
                 quickPublishScheduleFields.classList.add('hidden');
                 return;
            } else {
                 quickPublishScheduleFields.classList.remove('hidden');
            }

            selectedQuickPublishItems.forEach((item, index) => {
                 const itemDiv = document.createElement('div');
                 itemDiv.className = 'p-4 bg-secondary-theme rounded-lg shadow-sm flex flex-col space-y-3';
                 itemDiv.innerHTML = `
                     <div class="flex justify-between items-start">
                         <div class="flex items-center space-x-3">
                             <img src="${item.poster_url}" alt="Poster" class="w-10 h-15 rounded object-cover flex-shrink-0">
                             <div>
                                 <p class="font-bold text-sm">${item.title} <span class="text-xs opacity-70">(${item.year})</span></p>
                                 <p class="text-xs opacity-60">${item.genres.slice(0, 2).join(', ')}</p>
                             </div>
                         </div>
                         <button type="button" onclick="removeQuickPublishItem(${index})" class="text-red-500 hover:text-red-700 p-1 rounded transition duration-200">
                             <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
                         </button>
                     </div>
                     <div class="grid grid-cols-3 gap-3">
                         <select class="input-style !p-2 !text-sm" name="qualidade" data-index="${index}" required>
                             <option value="">Qualidade</option>
                             <option value="1080p">1080p</option>
                             <option value="720p" selected>720p</option>
                             <option value="480p">480p</option>
                         </select>
                         <select class="input-style !p-2 !text-sm" name="idioma" data-index="${index}" required>
                             <option value="">Idioma</option>
                             <option value="dublado" selected>Dublado</option>
                             <option value="legendado">Legendado</option>
                             <option value="original">Original</option>
                         </select>
                         <input type="url" class="input-style col-span-1 !p-2 !text-sm" name="url" placeholder="URL do Link" data-index="${index}" value="${item.link || ''}" required>
                     </div>
                 `;
                 quickContentListContainer.appendChild(itemDiv);
                 
                 // Adiciona listeners para atualizar o objeto local (opcional, mas bom para reter dados se a lista mudar)
                 itemDiv.querySelector('[name="url"]').addEventListener('input', (e) => {
                     selectedQuickPublishItems[index].link = e.target.value;
                 });
            });
        }
        
        quickPublishForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (selectedQuickPublishItems.length === 0) return;
            
            quickPublishSubmitBtn.disabled = true;
            quickPublishText.textContent = 'Publicando...';
            quickLoadingSpinner.classList.remove('hidden');
            
            const batch = writeBatch(db);
            const isScheduled = quickIsUpcomingCheckbox.checked;
            
            let releaseTimestamp = null;
            if (isScheduled) {
                 const releaseDate = quickReleaseDateInput.value;
                 const releaseTime = quickReleaseTimeInput.value || '00:00';
                 if (!releaseDate) {
                     window.alert('Se a opção "Em Breve" está marcada, a data de lançamento é obrigatória.');
                     quickPublishSubmitBtn.disabled = false;
                     quickPublishText.textContent = `Publicar ${selectedQuickPublishItems.length} Filmes`;
                     quickLoadingSpinner.classList.add('hidden');
                     return;
                 }
                 const releaseDateTime = new Date(`${releaseDate}T${releaseTime}:00`);
                 releaseTimestamp = releaseDateTime.getTime();
                 
                 if (releaseTimestamp < Date.now()) {
                      window.alert('A data de lançamento não pode ser no passado ao agendar.');
                      quickPublishSubmitBtn.disabled = false;
                      quickPublishText.textContent = `Publicar ${selectedQuickPublishItems.length} Filmes`;
                      quickLoadingSpinner.classList.add('hidden');
                      return;
                 }
            }


            try {
                 document.querySelectorAll('#quick-content-list > div').forEach((itemDiv, index) => {
                     const item = selectedQuickPublishItems[index];
                     const quality = itemDiv.querySelector('[name="qualidade"]').value;
                     const language = itemDiv.querySelector('[name="idioma"]').value;
                     const url = itemDiv.querySelector('[name="url"]').value;

                     if (!quality || !language || !url) {
                          throw new Error(`Link do filme ${item.title} está incompleto.`);
                     }
                     
                     const docRef = doc(collection(db, PUBLIC_CONTENT_COLLECTION_PATH));
                     const data = {
                         ...item,
                         links: [{ qualidade: quality, idioma: language, url: url }],
                         createdAt: Date.now(),
                         updatedAt: Date.now(),
                         userId: userId,
                         is_upcoming: isScheduled,
                         releaseTimestamp: releaseTimestamp,
                     };
                     
                     // Remove o campo 'link' extra do objeto item
                     delete data.link;

                     batch.set(docRef, data);
                 });
                 
                 await batch.commit();

                 window.alert(`${selectedQuickPublishItems.length} Filmes ${isScheduled ? 'Agendados' : 'Publicados'} com sucesso!`);
                 
                 selectedQuickPublishItems = [];
                 renderQuickPublishList();
                 renderAdminView('editar');

            } catch (error) {
                console.error("Erro durante a publicação rápida:", error);
                window.alert(`Erro: ${error.message}`);
            } finally {
                 quickPublishSubmitBtn.disabled = false;
                 quickPublishText.textContent = `Publicar ${selectedQuickPublishItems.length} Filmes`;
                 quickLoadingSpinner.classList.add('hidden');
            }
        });


        // --- 10. Lógica do Firestore e Sincronização em Tempo Real ---

        async function setupFirestoreListeners() {
            if (!db) return; // Garante que o DB está inicializado
            
            // Carrega as preferências do usuário
            await loadUserPreferences();


            // 1. Listener de Conteúdo (Feed/Edição)
            const contentCollectionRef = collection(db, PUBLIC_CONTENT_COLLECTION_PATH);
            const contentQuery = query(contentCollectionRef, orderBy('updatedAt', 'desc')); 

            onSnapshot(contentQuery, (snapshot) => {
                const now = Date.now();
                allContent = [];
                publishedContent = [];
                upcomingContent = [];
                
                snapshot.forEach((doc) => {
                    const content = { id: doc.id, ...doc.data() };
                    allContent.push(content);
                    
                    // Lógica de agendamento (NOVO)
                    if (content.is_upcoming && content.releaseTimestamp && content.releaseTimestamp > now) {
                         upcomingContent.push(content);
                    } else {
                         publishedContent.push(content);
                    }
                });
                
                // Dispara notificação de lançamento se a data passou e não for mais "Em Breve"
                checkScheduledReleases(allContent);
                
                renderEditList(allContent); // Renderiza a lista completa para o admin
                renderPage(currentActivePage); // Renderiza a página atual com o conteúdo filtrado
                checkDeepLink(); // Verifica se há um modal a ser reaberto
            }, (error) => {
                console.error("Erro ao ouvir o Firestore (Content):", error);
                contentListContainer.innerHTML = `<div class="p-4 bg-red-100 text-red-700 rounded-lg">Erro ao carregar conteúdo: ${error.message}</div>`;
            });
            
            // 2. Listener de Notificações (Ativas)
            const notifCollectionRef = collection(db, NOTIFICATIONS_COLLECTION_PATH);
            const notifQuery = query(notifCollectionRef, orderBy('timestamp', 'desc')); 

            onSnapshot(notifQuery, (snapshot) => {
                 // Filtra notificações que não estão no histórico de deletadas
                 const newNotifications = [];
                 let hasNew = false;
                 
                 snapshot.forEach((doc) => {
                     const notif = { id: doc.id, ...doc.data() };
                     
                     // Verifica se a notificação está marcada como excluída localmente
                     const isDeletedLocally = localDeletedNotifs.some(deleted => deleted.id === notif.id);
                     
                     if (!isDeletedLocally) {
                          newNotifications.push(notif);
                     }
                     
                     // Dispara pop-up se a notificação é nova no feed (e não está deletada)
                     if (snapshot.docChanges().some(change => change.type === "added" && change.doc.id === doc.id) && !isDeletedLocally) {
                         // Evita disparar pop-up se estiver em modo admin
                         if (!isAdminMode) { 
                             showNotification(notif);
                         }
                         hasNew = true;
                     }
                 });
                 
                 clientNotifications = newNotifications; 
                 renderGlobalNotifications(); 
 
                 if (hasNew) {
                      // Simplesmente mostra o ponto vermelho para indicar novos
                      unreadNotifsCount.classList.remove('hidden');
                 }
            }, (error) => {
                 console.error("Erro ao ouvir o Firestore (Notifications):", error);
            });
            
            // 3. Listener de Feedbacks
            const feedbackCollectionRef = collection(db, FEEDBACK_COLLECTION_PATH);
            const feedbackQuery = query(feedbackCollectionRef, orderBy('timestamp', 'desc'));

            onSnapshot(feedbackQuery, (snapshot) => {
                clientFeedbacks = [];
                snapshot.forEach((doc) => {
                    clientFeedbacks.push({ id: doc.id, ...doc.data() });
                });
                renderFeedbackList(clientFeedbacks);
            }, (error) => {
                console.error("Erro ao ouvir o Firestore (Feedbacks):", error);
                feedbacksListContainer.innerHTML = `<div class="p-4 bg-red-100 text-red-700 rounded-lg">Erro ao carregar feedbacks: ${error.message}</div>`;
            });
            
            // 4. Listener do Histórico de Notificações Deletadas (NOVO)
            const deletedNotifCollectionRef = collection(db, DELETED_NOTIFS_COLLECTION_PATH);
            const deletedNotifQuery = query(deletedNotifCollectionRef, orderBy('timestamp', 'desc'));

            onSnapshot(deletedNotifQuery, (snapshot) => {
                deletedNotifications = [];
                snapshot.forEach((doc) => {
                    deletedNotifications.push({ id: doc.id, ...doc.data() });
                });
                 // Atualiza a lista local de exclusão para sincronizar o pop-up
                 localDeletedNotifs = deletedNotifications.map(n => ({ id: n.notif_id }));
                 localStorage.setItem(DELETED_NOTIFS_KEY, JSON.stringify(localDeletedNotifs));
                 
                 // Re-renderiza o modal se estiver aberto
                 if (globalNotifsModal.classList.contains('active')) {
                      renderGlobalNotifications();
                 }
            }, (error) => {
                console.error("Erro ao ouvir o Firestore (Deleted Notifs):", error);
            });
        }
        
        
        // NOVO: Verifica o agendamento e dispara notificações de lançamento
        async function checkScheduledReleases(allContent) {
            const now = Date.now();
            const batch = writeBatch(db);
            let releasedContent = [];

            allContent.forEach(content => {
                if (content.is_upcoming && content.releaseTimestamp && content.releaseTimestamp <= now) {
                    releasedContent.push(content);
                }
            });

            if (releasedContent.length > 0) {
                 for (const content of releasedContent) {
                     const contentRef = doc(db, PUBLIC_CONTENT_COLLECTION_PATH, content.id);
                     
                     // 1. Atualiza o conteúdo no Firestore para não ser mais "Em Breve"
                     batch.update(contentRef, {
                         is_upcoming: false,
                         // Mantém o releaseTimestamp para histórico se necessário, mas remove o campo agendamento
                     });
                     
                     // 2. Dispara notificação para todos os usuários que marcaram "Notificar-me" (Simulação)
                     // No app real, essa lógica de envio em massa (FCM/Cloud Functions) seria complexa.
                     // Aqui, simulamos a notificação para o usuário local.
                      if (localUpcomingPrefs[content.id]) {
                          await sendNotification({
                              type: 'lançamento',
                              title: content.title,
                              poster_url: content.poster_url,
                              item_type: content.type,
                              content_id: content.id,
                          });
                          // Remove a preferência local para não notificar novamente
                          delete localUpcomingPrefs[content.id];
                          localStorage.setItem(UPCOMING_PREFS_KEY, JSON.stringify(localUpcomingPrefs));
                          // A lógica de update do Firebase user preferences foi ignorada aqui para simplificar.
                      }
                 }
                 
                 await batch.commit(); // Executa a atualização no Firestore
            }
        }


        // --- 10.1 Notificação Firehose e Global Notifications Modal ---

        async function sendNotification(data) {
            try {
                const notifRef = doc(collection(db, NOTIFICATIONS_COLLECTION_PATH));
                await setDoc(notifRef, {
                    ...data,
                    timestamp: Date.now(),
                });
            } catch (error) {
                console.error("Erro ao enviar notificação (Permissão?):", error);
                throw error;
            }
        }
        
        const notifModal = document.getElementById('notification-modal');
        const notifPoster = document.getElementById('notif-poster');
        const notifTitle = document.getElementById('notif-title');
        const notifMessage = document.getElementById('notif-message');
        const notifTime = document.getElementById('notif-time');
        const globalNotifsModal = document.getElementById('global-notifications-modal');
        const notifsListContainer = document.getElementById('notifications-list');
        const unreadNotifsCount = document.getElementById('unread-notifs-count');
        const toggleNotifHistoryBtn = document.getElementById('toggle-notif-history'); // NOVO
        
        let notifTimeout;
        let isHistoryView = false; // NOVO

        window.hideNotification = () => {
            notifModal.classList.remove('show');
            setTimeout(() => notifModal.classList.add('hidden'), 400); 
        }

        function getNotificationMessage(data) {
            const { type, item_type } = data;
            const itemLabel = item_type === 'movie' ? 'Filme' : 'Série';
            
            let actionText;
            if (type === 'publicado') {
                actionText = 'Um novo conteúdo foi publicado!';
            } else if (type === 'atualizado') {
                actionText = `${itemLabel} atualizado!`;
            } else if (type === 'excluído') {
                actionText = `${itemLabel} removido.`;
            } else if (type === 'lançamento') { // NOVO
                 actionText = `ACABOU DE CHEGAR: ${itemLabel} lançado!`;
            } else {
                actionText = 'O conteúdo foi alterado.';
            }
            return actionText;
        }

        function showNotification(data) {
            clearTimeout(notifTimeout);
            
            // Salva o ID da notificação no modal para uso posterior
            notifModal.dataset.notifId = data.id;
            
            notifPoster.src = data.poster_url;
            notifPoster.onerror = () => notifPoster.src = 'https://placehold.co/40x60/4b5563/ffffff?text=N'; // Fallback
            notifTitle.textContent = data.title;
            notifMessage.textContent = getNotificationMessage(data);
            notifTime.textContent = new Date(data.timestamp).toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'});
            
            notifModal.classList.remove('hidden');
            void notifModal.offsetWidth; 
            notifModal.classList.add('show');

            notifTimeout = setTimeout(hideNotification, 8000);
        }
        
        // NOVO: Lógica de clique no pop-up
        window.handleNotifClick = (e) => {
             const notifId = e.currentTarget.dataset.notifId;
             const notif = clientNotifications.find(n => n.id === notifId) || deletedNotifications.find(n => n.notif_id === notifId);
             
             if (notif && notif.content_id) {
                 const content = allContent.find(c => c.id === notif.content_id);
                 if (content) {
                     showDetailModal(content);
                 }
             }
             hideNotification();
        }

        function renderGlobalNotifications() {
            notifsListContainer.innerHTML = '';
            
            // Define qual lista usar (Ativas ou Histórico)
            const listToRender = isHistoryView ? deletedNotifications.map(n => ({...n, id: n.notif_id, timestamp: n.timestamp, isHistory: true})) : clientNotifications;
            
            // Atualiza o texto do botão Histórico
             toggleNotifHistoryBtn.textContent = isHistoryView ? 'Ativas' : 'Histórico';
             
            // Se estiver no histórico, o botão "Limpar Todas" deve ser "Restaurar Todas" (ou simplesmente limpar todas do histórico)
            document.getElementById('clear-all-notifs-btn').textContent = isHistoryView ? 'Limpar Histórico' : 'Limpar Ativas';

            if (listToRender.length === 0) {
                const msg = isHistoryView ? 'Nenhuma notificação no histórico de exclusão.' : 'Nenhuma notificação recente.';
                notifsListContainer.innerHTML = `<p class="text-center opacity-70 mt-8">${msg}</p>`;
                document.getElementById('clear-all-notifs-btn').disabled = true;
                return;
            }
            
            document.getElementById('clear-all-notifs-btn').disabled = false;

            // Renderiza a lista de notificações já ORDENADA (a mais nova está em [0])
            listToRender.forEach((notif) => {
                const notifItem = document.createElement('div');
                // Adiciona a classe para dar o efeito de clique e identifica o conteúdo
                notifItem.className = 'notification-item-clickable flex space-x-3 items-start p-3 bg-secondary-theme rounded-lg shadow-sm';
                notifItem.dataset.contentId = notif.content_id; 
                
                // Pega a notificação original se estiver no histórico
                 const notifData = notif.isHistory ? notif : clientNotifications.find(n => n.id === notif.id) || {};
                
                notifItem.innerHTML = `
                    <img src="${notifData.poster_url}" onerror="this.onerror=null;this.src='https://placehold.co/40x60/4b5563/ffffff?text=?';" class="w-10 h-15 rounded object-cover flex-shrink-0">
                    <div class="flex-1">
                        <p class="font-bold text-sm truncate">${notifData.title || 'Conteúdo Excluído'}</p>
                        <p class="text-xs mt-1">${getNotificationMessage(notifData)}</p>
                        <p class="text-xs opacity-60 mt-1">${new Date(notif.timestamp).toLocaleString('pt-BR', {dateStyle: 'short', timeStyle: 'short'})} ${notif.isHistory ? '(Histórico)' : ''}</p>
                    </div>
                    <button data-notif-id="${notif.id}" class="remove-notif-btn text-red-500 hover:text-red-700 p-1 rounded transition duration-200">
                         ${isHistoryView ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>' : '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>'}
                    </button>
                `;
                notifsListContainer.appendChild(notifItem);

                // Adiciona listener para abrir o modal de detalhes
                notifItem.addEventListener('click', (e) => {
                    if (e.target.closest('.remove-notif-btn')) return;

                    const contentId = e.currentTarget.dataset.contentId;
                    const content = publishedContent.find(c => c.id === contentId);
                    
                    if (content) {
                        toggleGlobalNotifications(); 
                        showDetailModal(content); 
                    } else {
                        window.alert('O conteúdo foi removido ou ainda não foi lançado.');
                    }
                });
            });

            document.querySelectorAll('.remove-notif-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                     const notifId = e.currentTarget.dataset.notifId;
                     if (isHistoryView) {
                         // Restaura a notificação (move do histórico para ativa)
                         window.restoreNotification(notifId);
                     } else {
                         // Remove a notificação (move para o histórico)
                         window.removeNotification(notifId);
                     }
                });
            });
        }
        
        // NOVO: Alterna entre a visualização de Ativas e Histórico
        toggleNotifHistoryBtn.addEventListener('click', () => {
             isHistoryView = !isHistoryView;
             renderGlobalNotifications();
        });


        // CORRIGIDO: Exclui do Firestore (move para o Histórico)
        window.removeNotification = async (notifId) => {
            try {
                 const notif = clientNotifications.find(n => n.id === notifId);
                 if (!notif) return;
                 
                 const batch = writeBatch(db);
                 
                 // 1. Move a notificação para a coleção DELETED_NOTIFS
                 const deletedRef = doc(db, DELETED_NOTIFS_COLLECTION_PATH, notifId);
                 batch.set(deletedRef, {
                      notif_id: notifId,
                      ...notif,
                      timestamp: Date.now(), // Atualiza o timestamp para ordenação do histórico
                 });
                 
                 // 2. Remove da coleção NOTIFICATIONS (ativa)
                 const notifRef = doc(db, NOTIFICATIONS_COLLECTION_PATH, notifId);
                 batch.delete(notifRef);

                 await batch.commit();
                 
            } catch (error) {
                console.error("Erro ao remover notificação (Firestore):", error);
                window.alert("Falha ao remover notificação.");
            }
        }
        
        // NOVO: Restaura a notificação (move do Histórico para Ativas)
        window.restoreNotification = async (notifId) => {
             try {
                 const notifHistory = deletedNotifications.find(n => n.notif_id === notifId);
                 if (!notifHistory) return;
                 
                 const batch = writeBatch(db);
                 
                 // 1. Remove da coleção DELETED_NOTIFS
                 const deletedRef = doc(db, DELETED_NOTIFS_COLLECTION_PATH, notifId);
                 batch.delete(deletedRef);
                 
                 // 2. Cria novamente na coleção NOTIFICATIONS (ativa)
                 const notifRef = doc(db, NOTIFICATIONS_COLLECTION_PATH, notifId);
                 // Cria uma nova cópia, exceto o notif_id extra e o timestamp (será gerado pelo listener se necessário, ou só o updated)
                 const { notif_id, ...rest } = notifHistory;
                 batch.set(notifRef, {
                      ...rest,
                      timestamp: Date.now(),
                 });

                 await batch.commit();
                 
             } catch (error) {
                 console.error("Erro ao restaurar notificação:", error);
                 window.alert("Falha ao restaurar notificação.");
             }
        }
        
        // NOVO: Exclui permanentemente do Histórico
        window.deleteNotificationFromHistory = async (notifId) => {
             try {
                 const deletedRef = doc(db, DELETED_NOTIFS_COLLECTION_PATH, notifId);
                 await deleteDoc(deletedRef);
             } catch (error) {
                 console.error("Erro ao excluir notificação do histórico:", error);
                 window.alert("Falha ao excluir notificação do histórico.");
             }
        }

        document.getElementById('clear-all-notifs-btn').addEventListener('click', async () => {
             if (isHistoryView) {
                 // Limpa Histórico (Exclusão permanente)
                 if (!window.confirm("Tem certeza que deseja limpar todo o histórico de notificações? Essa ação é permanente.")) return;
                 
                 const batch = writeBatch(db);
                 deletedNotifications.forEach(notif => {
                      const deletedRef = doc(db, DELETED_NOTIFS_COLLECTION_PATH, notif.notif_id);
                      batch.delete(deletedRef);
                 });
                 await batch.commit();
                 window.alert("Histórico de notificações limpo.");
             } else {
                 // Limpa Ativas (Move para o Histórico)
                 if (!window.confirm("Tem certeza que deseja mover todas as notificações ativas para o histórico?")) return;
                 
                 const batch = writeBatch(db);
                 clientNotifications.forEach(notif => {
                     // 1. Move a notificação para a coleção DELETED_NOTIFS
                     const deletedRef = doc(db, DELETED_NOTIFS_COLLECTION_PATH, notif.id);
                     batch.set(deletedRef, {
                          notif_id: notif.id,
                          ...notif,
                          timestamp: Date.now(), 
                     });
                     
                     // 2. Remove da coleção NOTIFICATIONS (ativa)
                     const notifRef = doc(db, NOTIFICATIONS_COLLECTION_PATH, notif.id);
                     batch.delete(notifRef);
                 });
                 await batch.commit();
                 window.alert("Notificações ativas movidas para o histórico.");
             }
        });

        function toggleGlobalNotifications() {
            const isActive = globalNotifsModal.classList.toggle('active');
            if (isActive) {
                // Ao abrir o modal, resetamos o ponto vermelho
                unreadNotifsCount.classList.add('hidden');
                // Garante que a visualização inicial é a de Notificações Ativas
                isHistoryView = false; 
                renderGlobalNotifications();
            }
        }

        toggleGlobalNotifsBtn.addEventListener('click', toggleGlobalNotifications);
        document.getElementById('close-global-notifs-btn').addEventListener('click', toggleGlobalNotifications);


        // --- Renderização de Listas e Feeds ---

        // Renderiza a lista no Painel de Edição
        function renderEditList(contentArray) {
            contentListContainer.innerHTML = '';
            upcomingAdminListContainer.innerHTML = ''; // Limpa a lista de agendamentos

            if (contentArray.length === 0) {
                contentListContainer.innerHTML = `<div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Nenhum conteúdo publicado ainda.</div>`;
                return;
            }

            contentArray.sort((a, b) => b.updatedAt - a.updatedAt); // Ordena pelo mais recente
            
            const adminUpcomingList = contentArray.filter(c => c.is_upcoming);
            const adminPublishedList = contentArray.filter(c => !c.is_upcoming);
            
            // 1. Lista de Conteúdo Publicado (Editar)
            if (adminPublishedList.length === 0) {
                 contentListContainer.innerHTML = `<div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Nenhum conteúdo publicado (no ar) no momento.</div>`;
            } else {
                 adminPublishedList.forEach(content => {
                     contentListContainer.appendChild(createAdminListItem(content, false));
                 });
            }
            
            // 2. Lista de Conteúdo Agendado (Admin)
            if (adminUpcomingList.length === 0) {
                upcomingAdminListContainer.innerHTML = `<div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Nenhum conteúdo agendado.</div>`;
            } else {
                adminUpcomingList.forEach(content => {
                     upcomingAdminListContainer.appendChild(createAdminListItem(content, true));
                });
            }
            
            // Renderiza o painel de admin correto se estiver no modo admin
            if (isAdminMode) {
                 renderAdminView(currentAdminView);
            }
        }
        
        // Função utilitária para criar o item da lista de Admin
        function createAdminListItem(content, isUpcoming) {
            const item = document.createElement('div');
            item.className = 'flex justify-between items-center p-4 bg-secondary-theme rounded-lg shadow-md';
            
            let badgeHTML = '';
            if (isUpcoming && content.releaseTimestamp) {
                const releaseDate = new Date(content.releaseTimestamp).toLocaleDateString('pt-BR');
                const releaseTime = new Date(content.releaseTimestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                badgeHTML = `<span class="text-xs font-bold text-yellow-600 ml-2">(${releaseDate} ${releaseTime})</span>`;
            } else if (!isUpcoming && content.is_upcoming === false) {
                 badgeHTML = `<span class="text-xs font-bold text-green-600 ml-2">(Publicado)</span>`;
            }


            item.innerHTML = `
                <div class="flex items-center space-x-4">
                    <img src="${content.poster_url}" onerror="this.onerror=null;this.src='https://placehold.co/40x60/4b5563/ffffff?text=?';" class="w-10 h-15 rounded object-cover flex-shrink-0">
                    <div>
                        <p class="font-bold">${content.title} <span class="text-xs font-normal opacity-70">(${content.year})</span> ${badgeHTML}</p>
                        <p class="text-xs opacity-60">${content.type === 'movie' ? 'Filme' : 'Série'}</p>
                    </div>
                </div>
                <div class="flex space-x-3">
                    <button onclick="editContent('${content.id}')" class="text-blue-500 hover:text-blue-700 font-semibold text-sm">Editar</button>
                    <button onclick="promptDeleteContent('${content.id}')" class="text-red-500 hover:text-red-700 font-semibold text-sm">Excluir</button>
                </div>
            `;
            return item;
        }


        // Renderiza a lista no Painel de Feedbacks
        function renderFeedbackList(feedbacksArray) {
            feedbacksListContainer.innerHTML = '';

            if (feedbacksArray.length === 0) {
                feedbacksListContainer.innerHTML = `<div class="p-4 bg-secondary-theme/50 rounded-lg text-center opacity-70">Nenhum feedback recebido ainda.</div>`;
                return;
            }

            feedbacksArray.forEach(feedback => {
                const item = document.createElement('div');
                item.className = 'p-4 bg-secondary-theme rounded-xl shadow-md space-y-2 border-l-4 border-red-600'; // Alterado para red-600
                item.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <span class="text-xs font-bold uppercase bg-red-200 text-red-800 dark:bg-red-800 dark:text-red-200 px-2 py-0.5 rounded-full">${feedback.type}</span>
                            <p class="text-xs opacity-60 mt-1">Enviado em: ${new Date(feedback.timestamp).toLocaleString('pt-BR')}</p>
                        </div>
                        <button onclick="promptDeleteFeedback('${feedback.id}')" class="text-red-500 hover:text-red-700 p-1 rounded transition duration-200 flex-shrink-0">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                        </button>
                    </div>
                    <p class="text-base mt-2">${feedback.message}</p>
                    <p class="text-xs opacity-50 pt-2 border-t border-gray-300 dark:border-gray-700 break-words">UID: ${feedback.userId}</p>
                `;
                feedbacksListContainer.appendChild(item);
            });
        }
        
        // Execução real da exclusão de Feedback (Chamada após a confirmação no modal)
        window.deleteFeedback = async (docId) => {
            try {
                const feedbackRef = doc(db, FEEDBACK_COLLECTION_PATH, docId);
                await deleteDoc(feedbackRef);
                window.alert("Feedback excluído com sucesso!");
            } catch (error) {
                console.error("Erro ao excluir feedback:", error);
                window.alert("Falha ao excluir feedback.");
            }
        }


        // --- 11. Lógica da Aba Explorar (Funcional) ---
        
        function renderExploreContent() {
            explorePanel.classList.remove('hidden');

            // Renderiza o cabeçalho de filtros
            explorePanel.innerHTML = `
                <div class="p-6 bg-secondary-theme/50 rounded-xl shadow-lg mb-8">
                    <h3 class="text-xl font-bold mb-4">Filtros de Exploração</h3>
                    
                    <div class="relative mb-6">
                        <input type="text" id="explore-search-input" class="input-style pl-10" placeholder="Pesquisar por Título, Gênero ou Ator...">
                        <svg class="w-5 h-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></svg>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-6">
                        
                        <div>
                            <p class="font-medium mb-2 text-sm">Ordenar por</p>
                            <div class="relative">
                                <select id="sort-filter" class="input-style select-style" data-filter="sort">
                                    <option value="popularidade" ${currentFilters.sort === 'popularidade' ? 'selected' : ''}>Popularidade</option>
                                    <option value="melhores-avaliados" ${currentFilters.sort === 'melhores-avaliados' ? 'selected' : ''}>Título (A-Z)</option>
                                    <option value="lancamentos" ${currentFilters.sort === 'lancamentos' ? 'selected' : ''}>Lançamentos</option>
                                </select>
                            </div>
                        </div>

                        <div>
                            <p class="font-medium mb-2 text-sm">Década (Ano de Lançamento)</p>
                            <div class="relative">
                                <select id="decade-filter" class="input-style select-style" data-filter="decade">
                                    ${DECADAS.map(d => `<option value="${d.toLowerCase().replace(' ', '-')}" ${currentFilters.decade === d.toLowerCase().replace(' ', '-') ? 'selected' : ''}>${d}</option>`).join('')}
                                </select>
                            </div>
                        </div>

                        <div>
                            <p class="font-medium mb-2 text-sm">Gênero</p>
                            <div class="relative">
                                <select id="genre-filter" class="input-style select-style" data-filter="genre">
                                    <option value="todos" ${currentFilters.genre === 'todos' ? 'selected' : ''}>Todos</option>
                                    ${GENRES.map(g => `<option value="${g.toLowerCase().replace(' ', '-')}">${g}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4 mt-8">
                        <button id="apply-filters-btn" class="w-full sm:w-1/2 py-2 px-4 bg-red-600 text-white font-bold rounded-lg shadow-xl hover:bg-red-700 transition duration-300 text-sm">
                            Aplicar Filtros
                        </button>
                        <button id="surprise-me-btn" class="w-full sm:w-1/2 py-2 px-4 bg-blue-600 text-white font-bold rounded-lg shadow-xl hover:bg-blue-700 transition duration-300 text-sm">
                              <span class="flex items-center justify-center space-x-2">
                                   <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 12H3"/><path d="M12 21V3"/><path d="M17 21V3"/><path d="M21 12H13"/></svg>
                                   <span>Surpreenda-me!</span>
                              </span>
                        </button>
                    </div>
                </div>
                
                <div class="text-center mb-6">
                    <p id="results-count" class="text-xl font-bold opacity-80"></p>
                </div>
                 <div id="explore-results" class="grid grid-cols-2 lg:grid-cols-4 gap-4">
                    <p class="col-span-full text-center opacity-70">Aguardando filtros para exibir resultados.</p>
                </div>
            `;
            
            document.getElementById('apply-filters-btn').addEventListener('click', applyFilters);
            document.getElementById('explore-search-input').addEventListener('input', applyFilters); // Aplica o filtro ao digitar
            document.getElementById('surprise-me-btn').addEventListener('click', showRandomContent);
            
            // Aplica os filtros iniciais ao carregar a página
            applyFilters();
        }
        
        function applyFilters() {
            const exploreResultsContainer = document.getElementById('explore-results');
            const resultsCountDisplay = document.getElementById('results-count');

            if (!exploreResultsContainer) return; 

            const sort = document.getElementById('sort-filter').value;
            const decade = document.getElementById('decade-filter').value;
            const genre = document.getElementById('genre-filter').value;
            const searchTerm = document.getElementById('explore-search-input').value.toLowerCase().trim();

            currentFilters = { sort, decade, genre };

            let results = publishedContent.slice(); // Apenas conteúdo publicado

            // 1. Filtrar por Termo de Pesquisa (Título, Gênero, Ator)
            if (searchTerm.length > 0) {
                results = results.filter(item => 
                    item.title.toLowerCase().includes(searchTerm) ||
                    item.genres.some(g => g.toLowerCase().includes(searchTerm)) ||
                    item.actors.some(a => a.toLowerCase().includes(searchTerm))
                );
            }

            // 2. Filtrar por Gênero (aplicado após a busca textual)
            if (genre !== 'todos') {
                const targetGenre = genre.toLowerCase().replace('-', ' ');
                results = results.filter(item => 
                    item.genres.some(g => g.toLowerCase().trim() === targetGenre)
                );
            }

            // 3. Filtrar por Década (simulando a lógica de ano)
            if (decade !== 'todas') {
                const startYearStr = decade.replace('anos-', '').split('-')[0];
                const startYear = parseInt(startYearStr) || 0;
                const endYear = startYear + 9;
                
                results = results.filter(item => {
                    const year = parseInt(item.year);
                    if (startYear === 0) return true; 
                    return year >= startYear && year <= endYear;
                });
            }

            // 4. Ordenação
            if (sort === 'lancamentos') {
                results.sort((a, b) => parseInt(b.year) - parseInt(a.year));
            } else if (sort === 'popularidade') {
                results.sort((a, b) => b.updatedAt - a.updatedAt);
            } else if (sort === 'melhores-avaliados') {
                 results.sort((a, b) => a.title.localeCompare(b.title));
            }

            // Renderizar os resultados
            exploreResultsContainer.innerHTML = '';
            resultsCountDisplay.textContent = `${results.length} Conteúdos Encontrados`;
            
            if (results.length === 0) {
                exploreResultsContainer.innerHTML = `
                    <div class="col-span-full text-center py-12">
                        <p class="text-xl opacity-80">Nenhum resultado encontrado para os filtros selecionados.</p>
                        <p class="text-sm opacity-60 mt-2">Tente alterar os critérios de busca.</p>
                    </div>
                `;
                return;
            }

            results.forEach(content => {
                const posterDiv = document.createElement('div');
                posterDiv.className = 'poster-card';
                posterDiv.style.backgroundImage = `url(${content.poster_url})`;
                posterDiv.dataset.contentId = content.id;
                
                posterDiv.addEventListener('click', () => showDetailModal(content));

                // Selo de temporadas (apenas séries)
                 let badgeHTML = '';
                 if (content.type === 'series' && content.seasons?.length > 0) {
                     const count = content.seasons.length;
                     badgeHTML = `<span class="release-badge bg-blue-500 top-2 right-2">${count}ª Temp.</span>`;
                 }

                posterDiv.innerHTML = `
                    ${badgeHTML}
                    <div class="poster-info">
                        </div>
                `;
                exploreResultsContainer.appendChild(posterDiv);
            });
        }
        
        // Função para mostrar um conteúdo aleatório
        function showRandomContent() {
             if (publishedContent.length === 0) {
                 window.alert("Não há conteúdo publicado para te surpreender!");
                 return;
             }
             
             // Escolhe um índice aleatório
             const randomIndex = Math.floor(Math.random() * publishedContent.length);
             const randomContent = publishedContent[randomIndex];
             
             // Abre o modal de detalhes
             showDetailModal(randomContent);
        }

        // --- 12. Lógica do Modal de Detalhes (Página de Detalhes) ---
        
        // NOVO: Rastreia o conteúdo visualizado (apenas séries)
        function trackViewedContent(content) {
            if (isAdminMode || !content.id || content.type === 'movie' || content.is_upcoming) return; 
            
            let viewed = JSON.parse(localStorage.getItem(VIEWED_CONTENT_KEY) || '[]');
            
            // Remove o item se ele já existir (para movê-lo para o topo)
            viewed = viewed.filter(item => item.id !== content.id);
            
            // Adiciona o novo item no início, mantendo apenas os dados essenciais
            viewed.unshift({
                id: content.id,
                title: content.title,
                poster_url: content.poster_url,
                type: content.type,
                lastViewed: Date.now()
            });
            
            // Limita o tamanho do histórico (máximo de 10)
            viewed = viewed.slice(0, 10);
            
            localStorage.setItem(VIEWED_CONTENT_KEY, JSON.stringify(viewed));
            
            // Renderiza novamente se estiver na página de séries para atualizar o carrossel
            if (currentActivePage === 'series') {
                renderFeedContent('series');
            }
        }
        
        // LÓGICA DE MARCAR EPISÓDIO COMO VISTO
        window.toggleWatchedEpisode = (contentId, seasonNum, episodeNum, markAsWatched = null) => {
            const key = `${contentId}-${seasonNum}-${episodeNum}`;
            
            if (!watchedEpisodes[contentId]) {
                watchedEpisodes[contentId] = {};
            }
            
            let isWatched = watchedEpisodes[contentId][key] === true;
            let targetWatchedState = (markAsWatched === null) ? !isWatched : markAsWatched;

            if (targetWatchedState) {
                watchedEpisodes[contentId][key] = true;
            } else {
                delete watchedEpisodes[contentId][key];
            }

            localStorage.setItem(WATCHED_EPISODES_KEY, JSON.stringify(watchedEpisodes));
            
            // Atualiza o ícone do olho na interface
            const iconElement = document.querySelector(`[data-watch-key="${key}"]`);
            if (iconElement) {
                iconElement.innerHTML = targetWatchedState ? getWatchedIcon() : getUnwatchedIcon();
                iconElement.classList.toggle('text-gray-400', !targetWatchedState);
                iconElement.classList.toggle('text-green-500', targetWatchedState);
            }
            
            // Se marcou como visto, rastreia como visto recentemente (apenas séries)
            if (targetWatchedState) {
                 const seriesContent = allContent.find(c => c.id === contentId);
                 if (seriesContent) {
                     trackViewedContent(seriesContent);
                 }
            }
        }
        
        function getWatchedIcon() {
            // Icone de Olho Aberto (Visto - Lucide: Eye)
            return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>`;
        }

        function getUnwatchedIcon() {
            // CORRIGIDO: Icone de Olho Cortado (Não Visto - Lucide: EyeOff)
            return `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.9 5.8 12 12M12 12 6.1 18.2M12 12V3M12 12h9M12 12H3"/><path d="M12 17.5s3 7 10 7 10-7 10-7"/><path d="M2 12s3-7 10-7 10 7 10 7"/></svg>`;
        }

        // Função para copiar o link da página atual (simulada com content ID)
        window.copyLinkToClipboard = (contentId, title) => {
             // Simula o link real para a página de detalhes
             const simulatedLink = `${window.location.origin}${window.location.pathname}?id=${contentId}`; 

             // Uso de API de Clipboard (moderna)
             if (navigator.clipboard) {
                 navigator.clipboard.writeText(simulatedLink).then(() => {
                      linkText.textContent = `Link Copiado!`;
                      setTimeout(() => linkText.textContent = `Copiar Link`, 2000);
                 }).catch(err => {
                      console.error('Falha ao copiar:', err);
                      // Fallback para ambientes restritos (iframe)
                      fallbackCopyTextToClipboard(simulatedLink);
                      linkText.textContent = `Link Copiado! (Fallback)`;
                      setTimeout(() => linkText.textContent = `Copiar Link`, 2000);
                 });
             } else {
                  fallbackCopyTextToClipboard(simulatedLink);
                  linkText.textContent = `Link Copiado! (Fallback)`;
                  setTimeout(() => linkText.textContent = `Copiar Link`, 2000);
             }
        }

        function fallbackCopyTextToClipboard(text) {
             const textArea = document.createElement("textarea");
             textArea.value = text;
             textArea.style.position = "fixed"; 
             textArea.style.left = "-999999px"; 
             document.body.appendChild(textArea);
             textArea.focus();
             textArea.select();
             try {
                  document.execCommand('copy');
             } catch (err) {
                  console.error('Fallback: Falha ao copiar texto: ', err);
             }
             document.body.removeChild(textArea);
        }

        function closeDetailModal() {
            detailModal.classList.remove('active');
            // Remove a classe de bloqueio de rolagem do body
            document.body.classList.remove('overflow-hidden'); 
            // Limpa o estado da sessão para não reabrir
            sessionStorage.removeItem('detailContentId');

            // Limpa o estado dinâmico
            seriesLinksPanel.classList.add('hidden');
            similarContentPanel.classList.add('hidden'); // NOVO
        }

        closeDetailModalBtn.addEventListener('click', closeDetailModal);
        
        // Função utilitária para abrir o link em uma nova aba (sem simulação/confirmação)
        function openLinkInNewTab(url) {
             if (url && url.startsWith('http')) {
                 window.open(url, '_blank');
             } else {
                 console.error("URL inválida ou ausente. Não foi possível redirecionar:", url);
             }
        }
        // EXPÕE A FUNÇÃO PARA SER ACESSADA PELO HTML INLINE
        window.openLinkInNewTab = openLinkInNewTab;


        function showDetailModal(content) {
            // CORREÇÃO CRÍTICA: RASTREIA e BLOQUEIA ROLAGEM
            sessionStorage.setItem('detailContentId', content.id);
            document.body.classList.add('overflow-hidden'); 

            // 1. Preencher Campos Base
            detailTitle.textContent = content.title;
            detailTitleHeader.textContent = content.title; // Título no header
            detailHeader.style.backgroundImage = `url(${content.backdrop_url || content.poster_url})`;
            detailHeader.onerror = () => detailHeader.style.backgroundImage = `url('https://placehold.co/1920x400/1f2937/ffffff?text=Capa+do+Conteúdo')`;
            detailTypeYear.textContent = `${content.type === 'movie' ? 'Filme' : 'Série'} | ${content.year}`;
            detailGenres.textContent = content.genres.join(', ');
            detailSynopsis.textContent = content.synopsis;
            detailActors.textContent = content.actors.join(', ');
            
            // Configura Link Copiável
            linkText.textContent = `Copiar Link`;
            copyLinkBtn.onclick = () => window.copyLinkToClipboard(content.id, content.title);

            // 2. Lógica Específica (Filme vs Série vs Em Breve)
            
            // Limpa painéis dinâmicos
            seriesLinksPanel.classList.add('hidden');
            seriesSeasonsBadge.classList.add('hidden');
            upcomingBadge.classList.add('hidden');
            
            // Recria o botão principal (para limpar listeners antigos)
            const oldMainWatchBtn = document.getElementById('main-watch-btn');
            const newMainWatchBtn = oldMainWatchBtn.cloneNode(true);
            oldMainWatchBtn.replaceWith(newMainWatchBtn); 
            newMainWatchBtn.innerHTML = newMainWatchBtn.innerHTML; // Para reativar o getElementById nas crianças
            const newWatchIcon = newMainWatchBtn.querySelector('#watch-icon');
            const newWatchBtnText = newMainWatchBtn.querySelector('#watch-btn-text');

            const isUpcoming = content.is_upcoming && content.releaseTimestamp && content.releaseTimestamp > Date.now();
            
            if (isUpcoming) {
                 // --- EM BREVE: Notificar-me ---
                 upcomingBadge.classList.remove('hidden');
                 newWatchIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10Z"/><path d="m9 12 2 2 4-4"/></svg>`; // Ícone de Check/Sino
                 
                 const isUserInterested = localUpcomingPrefs[content.id];
                 newWatchBtnText.textContent = isUserInterested ? 'Receber Notificação (✔)' : 'Notificar-me sobre o Lançamento';
                 newMainWatchBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-red-600', 'hover:bg-red-700');
                 newMainWatchBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                 
                 newMainWatchBtn.addEventListener('click', () => {
                     toggleUpcomingNotification(content.id);
                     newWatchBtnText.textContent = localUpcomingPrefs[content.id] ? 'Receber Notificação (✔)' : 'Notificar-me sobre o Lançamento';
                 });
                 
                 // Renderiza a seção Em Breve no final
                 renderUpcomingInfoDetail(content);

            } else if (content.type === 'movie') {
                // --- FILME: Redireciona Diretamente no Botão Principal ---
                newWatchIcon.innerHTML = `<polygon points="5 3 19 12 5 21 5 3"/>`;
                newWatchBtnText.textContent = 'Assistir Agora';
                newMainWatchBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-blue-600', 'hover:bg-blue-700');
                newMainWatchBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                newMainWatchBtn.disabled = false;
                
                if (content.links && content.links.length > 0) {
                    const firstLink = content.links[0];
                    
                    newMainWatchBtn.addEventListener('click', () => {
                         // Redirecionamento direto para a URL do primeiro link
                         openLinkInNewTab(firstLink.url);
                    });
                } else {
                    newMainWatchBtn.disabled = true;
                    newMainWatchBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    newWatchBtnText.textContent = 'Nenhum Link Disponível';
                }

            } else if (content.type === 'series') {
                // --- SÉRIE: Exibe Painel de Temporadas e Episódios ---
                newWatchIcon.innerHTML = `<polygon points="5 3 19 12 5 21 5 3"/>`;
                newWatchBtnText.textContent = 'Ver Temporadas e Episódios';
                newMainWatchBtn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-blue-600', 'hover:bg-blue-700');
                newMainWatchBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                newMainWatchBtn.disabled = false;
                
                // Renderiza o badge de temporadas
                const seasonCount = content.seasons?.length || 0;
                if (seasonCount > 0) {
                    seriesSeasonsBadge.textContent = `${seasonCount} Temporada${seasonCount > 1 ? 's' : ''}`;
                    seriesSeasonsBadge.classList.remove('hidden');
                }

                // Renderiza a estrutura completa de temporadas/episódios
                renderSeriesLinksDetail(content);
                seriesLinksPanel.classList.remove('hidden'); // Exibe o painel de links

                // Ação do Botão Principal: Expande a primeira temporada e Rola
                newMainWatchBtn.addEventListener('click', () => {
                     // 1. Expande a primeira temporada (se houver)
                     const firstToggle = document.querySelector(`#seasons-links-container [data-season-toggle="0"]`);
                     const firstEpisodes = document.getElementById(`season-episodes-${content.id}-0`);

                     if (firstToggle && firstEpisodes.classList.contains('hidden')) {
                          // Simula o clique para expandir, se não estiver aberto
                          firstToggle.click(); 
                     }

                     // 2. Rola suavemente para o painel de links
                     const scrollContainer = document.getElementById('detail-modal-content').querySelector('.overflow-y-auto');
                     const targetOffset = seriesLinksPanel.offsetTop - 20; // 20px de margem
                     
                     // Rola a área de conteúdo do modal
                     scrollContainer.scrollTo({ top: targetOffset, behavior: 'smooth' });
                });
            }

            // 3. Renderiza Conteúdo Similar (TODOS OS TIPOS)
            renderSimilarContent(content);
            
            // 4. Abrir Modal
            detailModal.classList.add('active');
        }
        
        // NOVO: Renderiza a seção Em Breve no Modal de Detalhes
        function renderUpcomingInfoDetail(content) {
             const releaseDate = content.releaseTimestamp ? new Date(content.releaseTimestamp) : null;
             const dateText = releaseDate ? releaseDate.toLocaleDateString('pt-BR') : 'Data não definida';
             const timeText = releaseDate ? releaseDate.toLocaleTimeString('pt-BR', {hour: '2-digit', minute:'2-digit'}) : 'Horário não definido';

             const upcomingHtml = `
                 <div class="border-t pt-4 border-yellow-500/50">
                     <h3 class="text-xl font-bold mb-2 text-yellow-500">Detalhes do Lançamento</h3>
                     <p class="text-base opacity-90 font-semibold">Previsão: ${dateText} (${timeText})</p>
                     <p class="text-sm opacity-70 mt-2">Este conteúdo está agendado e será lançado automaticamente no feed principal na data e hora especificadas. Marque "Notificar-me" para receber um alerta.</p>
                 </div>
             `;
             // Injeta o HTML antes da seção de elenco
             const synopsisDiv = detailSynopsis.closest('div').nextElementSibling; // O div do Elenco
             if (synopsisDiv) {
                 const tempDiv = document.createElement('div');
                 tempDiv.innerHTML = upcomingHtml;
                 // Adiciona após a sinopse
                 detailSynopsis.closest('div').after(tempDiv.firstChild);
             }
        }
        
        
        // NOVO: Renderiza Conteúdo Similar
        function renderSimilarContent(currentContent) {
             similarContentContainer.innerHTML = '';
             similarContentPanel.classList.remove('hidden');
             noSimilarContent.classList.add('hidden');

             const MAX_SIMILAR = 8;
             let similarResults = [];
             
             // 1. Filtro por Gênero
             const targetGenres = currentContent.genres.map(g => g.toLowerCase().trim());
             const genreMatches = publishedContent.filter(c => 
                 c.id !== currentContent.id && 
                 c.genres.some(g => targetGenres.includes(g.toLowerCase().trim()))
             ).slice(0, MAX_SIMILAR);
             
             similarResults = [...genreMatches];

             // 2. Filtro por Título (para "Mesmo Universo" - Simulação)
             const titleKeywords = currentContent.title.toLowerCase().split(/\s+/)
                 .filter(word => word.length > 3 && isNaN(parseInt(word)));
                 
             const titleMatches = publishedContent.filter(c => 
                  c.id !== currentContent.id && 
                  !similarResults.some(s => s.id === c.id) && // Evita duplicatas
                  titleKeywords.some(keyword => c.title.toLowerCase().includes(keyword))
             ).slice(0, MAX_SIMILAR - similarResults.length);
             
             similarResults.push(...titleMatches);

             if (similarResults.length === 0) {
                 noSimilarContent.classList.remove('hidden');
                 return;
             }
             
             // Cria os cards do carrossel
             similarResults.forEach(content => {
                 const posterDiv = document.createElement('div');
                 posterDiv.className = 'carousel-item poster-card !min-w-[120px] !w-[120px] sm:!w-[140px]'; // Tamanho menor
                 posterDiv.style.backgroundImage = `url(${content.poster_url})`;
                 posterDiv.dataset.contentId = content.id; 

                 posterDiv.addEventListener('click', () => {
                     closeDetailModal(); // Fecha o modal atual antes de abrir o novo
                     showDetailModal(content);
                 });
                 
                 // Selo de temporadas (apenas séries)
                 let badgeHTML = '';
                 if (content.type === 'series' && content.seasons?.length > 0) {
                     const count = content.seasons.length;
                     badgeHTML = `<span class="release-badge bg-blue-500 top-2 right-2">${count}ª Temp.</span>`;
                 }

                 posterDiv.innerHTML = `
                      ${badgeHTML}
                      <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/30 to-transparent flex items-end p-2 opacity-0 hover:opacity-100 transition duration-300">
                          <p class="text-white text-xs font-semibold truncate w-full">${content.title}</p>
                      </div>
                 `;
                 similarContentContainer.appendChild(posterDiv);
             });
        }
        
        
        // NOVO: Função para verificar se há um deep link salvo
        function checkDeepLink() {
            const contentId = sessionStorage.getItem('detailContentId');
            if (contentId && allContent.length > 0) {
                const content = allContent.find(c => c.id === contentId);
                if (content) {
                    // Timeout para garantir que o DOM está pronto após o listener do Firestore
                    setTimeout(() => showDetailModal(content), 100);
                } else {
                    sessionStorage.removeItem('detailContentId');
                }
            }
        }


        // Funções de Renderização de Links de Detalhes
        // Recebe o objeto de conteúdo completo para acessar o ID
        function renderSeriesLinksDetail(content) {
            const seasons = content.seasons || [];
            seasonsLinksContainer.innerHTML = '';
            seasonsLinksContainer.dataset.seriesId = content.id;

            if (seasons.length === 0) {
                seasonsLinksContainer.innerHTML = '<p class="opacity-70 text-sm">Nenhuma temporada disponível.</p>';
                return;
            }
            
            seasons.forEach((season, sIndex) => {
                const seasonDiv = document.createElement('div');
                seasonDiv.className = 'season-detail-card p-4 bg-secondary-theme rounded-xl shadow-md';
                seasonDiv.dataset.seriesId = content.id; // Marca com o ID da série
                
                const isFirstSeason = sIndex === 0;
                
                // Título e Toggle (REMOVIDO A CONTAGEM DE EPISÓDIOS)
                seasonDiv.innerHTML = `
                    <button class="season-toggle-btn w-full flex justify-between items-center font-bold text-lg focus:outline-none py-1" data-season-toggle="${sIndex}" aria-expanded="${isFirstSeason}">
                        <span>Temporada ${season.number}</span>
                        <svg class="w-5 h-5 transition-transform duration-300 arrow-icon ${isFirstSeason ? 'rotate-180' : ''}" data-arrow="${sIndex}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>
                    </button>
                    <div id="season-episodes-${content.id}-${sIndex}" class="mt-4 space-y-3 ${isFirstSeason ? '' : 'hidden'}">
                        </div>
                `;
                seasonsLinksContainer.appendChild(seasonDiv);
                
                const episodesContainer = document.getElementById(`season-episodes-${content.id}-${sIndex}`);
                const toggleButton = seasonDiv.querySelector(`[data-season-toggle="${sIndex}"]`);
                const arrowIcon = seasonDiv.querySelector(`[data-arrow="${sIndex}"]`);

                // Adiciona a lógica de expansão/colapso
                toggleButton.addEventListener('click', () => {
                    const isHidden = episodesContainer.classList.toggle('hidden');
                    toggleButton.setAttribute('aria-expanded', !isHidden);
                    if (isHidden) {
                        arrowIcon.classList.remove('rotate-180');
                    } else {
                        arrowIcon.classList.add('rotate-180');
                    }
                });

                // Adiciona os episódios
                season.episodes.forEach((episode, eIndex) => {
                    const link = episode.links?.[0]; // Assume o primeiro link para o botão principal
                    if (!link) return; // Pula se não houver link
                    
                    const key = `${content.id}-${season.number}-${episode.number}`;
                    const isWatched = !!(watchedEpisodes[content.id] && watchedEpisodes[content.id][key]);
                    const watchedIcon = isWatched ? getWatchedIcon() : getUnwatchedIcon();
                    const watchedClass = isWatched ? 'text-green-500' : 'text-gray-400';

                    const episodeDiv = document.createElement('div');
                    episodeDiv.className = 'flex justify-between items-center p-3 bg-secondary-theme/80 rounded-lg border border-gray-300/50 dark:border-gray-700/50';
                    episodeDiv.innerHTML = `
                        <div class="flex items-center space-x-3">
                            <button onclick="toggleWatchedEpisode('${content.id}', ${season.number}, ${episode.number})" 
                                    class="flex-shrink-0 transition duration-200 hover:opacity-80 ${watchedClass}"
                                    data-watch-key="${key}">
                                ${watchedIcon}
                            </button>
                            
                            <div class="text-sm">
                                <p class="font-semibold">E${episode.number}: Episódio ${episode.number}</p>
                                <p class="text-xs opacity-60">Qualidade: ${link.qualidade}, Idioma: ${link.idioma}</p>
                            </div>
                        </div>
                        <button class="py-1 px-3 bg-red-600 text-white rounded-md text-xs hover:bg-red-700 transition duration-200"
                            onclick="openLinkInNewTab('${link.url}'); toggleWatchedEpisode('${content.id}', ${season.number}, ${episode.number}, true);">
                            Assistir
                        </button>
                    `;
                    episodesContainer.appendChild(episodeDiv);
                });
            });
        }
        
        // --- 13. Lógica do Modal de Feedback ---
        
        reportErrorBtn.addEventListener('click', () => {
             feedbackModal.classList.add('active');
             feedbackForm.reset(); // Limpa o formulário ao abrir
             if (window.innerWidth < 1024) {
                 toggleSidebar(); // Fecha a sidebar no mobile
             }
        });
        
        feedbackCancelBtn.addEventListener('click', () => {
             feedbackModal.classList.remove('active');
        });

        feedbackForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const feedbackType = document.getElementById('feedback-type').value;
            const feedbackMessage = document.getElementById('feedback-message').value;

            feedbackSubmitBtn.disabled = true;
            feedbackSubmitText.textContent = 'Enviando...';
            feedbackLoadingSpinner.classList.remove('hidden');

            try {
                const feedbackData = {
                    type: feedbackType,
                    message: feedbackMessage,
                    userId: userId,
                    timestamp: Date.now(),
                };
                
                const feedbackRef = doc(collection(db, FEEDBACK_COLLECTION_PATH));
                await setDoc(feedbackRef, feedbackData);
                
                feedbackModal.classList.remove('active');
                window.alert("Obrigado! Seu feedback foi enviado com sucesso."); // Confirmação

            } catch (error) {
                console.error("Erro ao enviar feedback:", error);
                window.alert("Falha ao enviar feedback. Tente novamente.");
            } finally {
                feedbackSubmitBtn.disabled = false;
                feedbackSubmitText.textContent = 'Enviar Feedback';
                feedbackLoadingSpinner.classList.add('hidden');
            }
        });

        // --- 14. Lógica do Modal de Aviso Legal (NOVO) ---
        
        function showLegalNoticeModal() {
            legalNoticeModal.classList.add('active');
            if (window.innerWidth < 1024) {
                 toggleSidebar(); // Fecha a sidebar no mobile
             }
        }
        function hideLegalNoticeModal() {
            legalNoticeModal.classList.remove('active');
        }
        legalNoticeBtn.addEventListener('click', showLegalNoticeModal);
        closeLegalNoticeBtn.addEventListener('click', hideLegalNoticeModal);

        // --- 15. Lógica do Toggle 'Continue Assistindo' (NOVO) ---
        
        function updateContinueWatchingToggleText() {
            if (isContinueWatchingHidden) {
                toggleContinueWatchingBtn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                toggleContinueWatchingBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                continueWatchingText.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>
                    <span>Mostrar Continue Assistindo</span>
                `;
            } else {
                toggleContinueWatchingBtn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                toggleContinueWatchingBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                continueWatchingText.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M5 12h14"/></svg>
                    <span>Ocultar Continue Assistindo</span>
                `;
            }
        }

        function toggleContinueWatching() {
            isContinueWatchingHidden = !isContinueWatchingHidden;
            localStorage.setItem(isContinueWatchingHiddenKey, isContinueWatchingHidden);
            updateContinueWatchingToggleText();
            
            // Renderiza a página principal novamente se necessário
            if (currentActivePage === 'inicio' || currentActivePage === 'series') {
                 renderFeedContent(currentActivePage);
            }
            if (window.innerWidth < 1024) {
                 toggleSidebar(); // Fechas a sidebar no mobile
            }
        }
        
        toggleContinueWatchingBtn.addEventListener('click', toggleContinueWatching);
        updateContinueWatchingToggleText(); // Inicializa o texto


        // --- 16. Inicialização (Página Padrão) ---
        // A renderPage('inicio') é chamada dentro do listener do Firestore para garantir que os dados estejam carregados.
        // renderPage('inicio'); 
    </script>
</body>
</html>
